From 00012ce4ed0e51282a9a3d1a0283ce9bb3251608 Mon Sep 17 00:00:00 2001
From: Arthur Sengileyev <arthur.sengileyev@gmail.com>
Date: Tue, 26 Sep 2023 14:52:38 +0300
Subject: [PATCH 2/3] Implement Unix domain socket support for VLAN

This change adds support for new QEMU stream netdev added in 7.2.0.
It is implemented as an opt-in mode for previously supported
platforms and the only supported mode on Windows.

Old FD netdev has changes only on podman side. Instead of previously
used QMP socket address, it now has VLAN dedicated socket address to
make both implementations more similar.

As VLAN socket address has short lifespan (it exists only after
forwarder has been started and before QEMU has finished startup),
it is not promoted to persisted machine settings, but is rather
calculated inside Start method.

Signed-off-by: Arthur Sengileyev <arthur.sengileyev@gmail.com>
---
 pkg/machine/e2e/README.md           |  23 +++
 pkg/machine/machine_windows.go      |  11 ++
 pkg/machine/qemu/config.go          |  26 +++-
 pkg/machine/qemu/machine.go         | 209 +++++++++++++++++-----------
 pkg/machine/qemu/machine_unix.go    |  52 ++++---
 pkg/machine/qemu/machine_windows.go |  58 ++++++--
 pkg/machine/wsl/machine.go          |   2 +-
 pkg/machine/wsl/util_windows.go     |   7 -
 8 files changed, 267 insertions(+), 121 deletions(-)

diff --git a/pkg/machine/e2e/README.md b/pkg/machine/e2e/README.md
index a516dfdb3..5a1a3f719 100644
--- a/pkg/machine/e2e/README.md
+++ b/pkg/machine/e2e/README.md
@@ -40,3 +40,26 @@ Note: To run specfic test files, add the test files to the end of the winmake co
 1. `./test/tools/build/ginkgo -vv  --tags "remote exclude_graphdriver_btrfs btrfs_noversion exclude_graphdriver_devicemapper containers_image_openpgp remote" -timeout=90m --trace --no-color  pkg/machine/e2e/.`
 
 Note: Add `--focus-file "basic_test.go" ` to only run basic test
+
+### QEMU (fd vlan)
+
+1. Install QEMU `brew install qemu`
+1. Install Podman (needed to have gvproxy binary) `brew install podman`
+1. `make podman-remote`
+1. `make .install.ginkgo`
+1. `export TMPDIR=/Users/<yourname>`
+1. `./test/tools/build/ginkgo -vv  --tags "remote exclude_graphdriver_btrfs btrfs_noversion exclude_graphdriver_devicemapper containers_image_openpgp remote" -timeout=90m --trace --no-color  pkg/machine/e2e/.`
+
+Note: Add `--focus-file "basic_test.go" ` to only run basic test
+
+### QEMU (UNIX domain socket vlan)
+
+1. Install QEMU `brew install qemu`
+1. Install Podman (needed to have gvproxy binary) `brew install podman`
+1. `make podman-remote`
+1. `make .install.ginkgo`
+1. `export TMPDIR=/Users/<yourname>`
+1. `export CONTAINERS_USE_SOCKET_VLAN=true`
+1. `./test/tools/build/ginkgo -vv  --tags "remote exclude_graphdriver_btrfs btrfs_noversion exclude_graphdriver_devicemapper containers_image_openpgp remote" -timeout=90m --trace --no-color  pkg/machine/e2e/.`
+
+Note: Add `--focus-file "basic_test.go" ` to only run basic test
diff --git a/pkg/machine/machine_windows.go b/pkg/machine/machine_windows.go
index 237264448..5aea8c33d 100644
--- a/pkg/machine/machine_windows.go
+++ b/pkg/machine/machine_windows.go
@@ -9,6 +9,17 @@ import (
 	"time"
 )
 
+// nolint // Cleaner to refer to the official OS constant names, and consistent with syscall
+const (
+	WM_QUIT = 0x12
+)
+
+func SendQuit(tid uint32) {
+	user32 := syscall.NewLazyDLL("user32.dll")
+	postMessage := user32.NewProc("PostThreadMessageW")
+	postMessage.Call(uintptr(tid), WM_QUIT, 0, 0)
+}
+
 func GetProcessState(pid int) (active bool, exitCode int) {
 	const da = syscall.STANDARD_RIGHTS_READ | syscall.PROCESS_QUERY_INFORMATION | syscall.SYNCHRONIZE
 	handle, err := syscall.OpenProcess(da, false, uint32(pid))
diff --git a/pkg/machine/qemu/config.go b/pkg/machine/qemu/config.go
index b1a84964f..4f6d04d2d 100644
--- a/pkg/machine/qemu/config.go
+++ b/pkg/machine/qemu/config.go
@@ -42,7 +42,7 @@ func (v *MachineVM) setQMPMonitorSocket() error {
 
 // setNewMachineCMD configure the CLI command that will be run to create the new
 // machine
-func (v *MachineVM) setNewMachineCMD(qemuBinary string) {
+func (v *MachineVM) setNewMachineCMD(qemuBinary string) error {
 	cmd := []string{qemuBinary}
 	// Add memory
 	cmd = append(cmd, []string{"-m", strconv.Itoa(int(v.Memory))}...)
@@ -55,7 +55,16 @@ func (v *MachineVM) setNewMachineCMD(qemuBinary string) {
 	// Add network
 	// Right now the mac address is hardcoded so that the host networking gives it a specific IP address.  This is
 	// why we can only run one vm at a time right now
-	cmd = append(cmd, []string{"-netdev", "socket,id=vlan,fd=3", "-device", "virtio-net-pci,netdev=vlan,mac=5a:94:ef:e4:0c:ee"}...)
+	if useFdVLan() {
+		cmd = append(cmd, []string{"-netdev", fdVlanNetdev()}...)
+	} else {
+		vlanSocket, err := machineSocket(v.Name, "vlan", "")
+		if err != nil {
+			return err
+		}
+		cmd = append(cmd, []string{"-netdev", socketVlanNetdev(vlanSocket.GetPath())}...)
+	}
+	cmd = append(cmd, []string{"-device", "virtio-net-pci,netdev=vlan,mac=5a:94:ef:e4:0c:ee"}...)
 
 	// Add serial port for readiness
 	cmd = append(cmd, []string{
@@ -67,6 +76,15 @@ func (v *MachineVM) setNewMachineCMD(qemuBinary string) {
 		"-device", "virtserialport,chardev=a" + v.Name + "_ready" + ",name=org.fedoraproject.port.0",
 		"-pidfile", v.VMPidFilePath.GetPath()}...)
 	v.CmdLine = cmd
+	return nil
+}
+
+func fdVlanNetdev() string {
+	return "socket,id=vlan,fd=3"
+}
+
+func socketVlanNetdev(path string) string {
+	return fmt.Sprintf("stream,id=vlan,server=off,addr.type=unix,addr.path=%s", path)
 }
 
 // NewMachine initializes an instance of a virtual machine based on the qemu
@@ -130,7 +148,9 @@ func (p *QEMUVirtualization) NewMachine(opts machine.InitOptions) (machine.VM, e
 	}
 
 	// configure command to run
-	vm.setNewMachineCMD(execPath)
+	if err := vm.setNewMachineCMD(execPath); err != nil {
+		return nil, err
+	}
 	return vm, nil
 }
 
diff --git a/pkg/machine/qemu/machine.go b/pkg/machine/qemu/machine.go
index 913484752..37afd48c2 100644
--- a/pkg/machine/qemu/machine.go
+++ b/pkg/machine/qemu/machine.go
@@ -42,6 +42,7 @@ const (
 	MountType9p          = "9p"
 	dockerSock           = "/var/run/docker.sock"
 	dockerConnectTimeout = 5 * time.Second
+	retryCountForStop    = 5
 )
 
 type MachineVM struct {
@@ -302,6 +303,9 @@ func (v *MachineVM) Init(opts machine.InitOptions) (bool, error) {
 	}
 
 	v.UID = os.Getuid()
+	if v.UID == -1 {
+		v.UID = 501 // Used on Windows to match FCOS image
+	}
 
 	// Add location of bootable image
 	v.CmdLine = append(v.CmdLine, "-drive", "if=virtio,file="+v.getImageFile())
@@ -523,30 +527,9 @@ func runStartVMCommand(cmd *exec.Cmd) error {
 	return nil
 }
 
-// connectToQMPMonitorSocket attempts to connect to the QMP Monitor Socket after
-// `maxBackoffs` attempts
-func (v *MachineVM) connectToQMPMonitorSocket(maxBackoffs int, backoff time.Duration) (conn net.Conn, err error) {
-	for i := 0; i < maxBackoffs; i++ {
-		if i > 0 {
-			time.Sleep(backoff)
-			backoff *= 2
-		}
-		conn, err = net.Dial("unix", v.QMPMonitor.Address.Path)
-		if err == nil {
-			break
-		}
-	}
-	return
-}
-
 // connectToPodmanSocket attempts to connect to the podman socket after
 // `maxBackoffs` attempts.
-func (v *MachineVM) connectToPodmanSocket(maxBackoffs int, backoff time.Duration, qemuPID int, errBuf *bytes.Buffer) (conn net.Conn, dialErr error) {
-	socketPath, err := getRuntimeDir()
-	if err != nil {
-		return nil, err
-	}
-
+func (v *MachineVM) connectToPodmanSocket(maxBackoffs int, backoff time.Duration, processName string, pid int, errBuf *bytes.Buffer, path string) (conn net.Conn, dialErr error) {
 	// The socket is not made until the qemu process is running so here
 	// we do a backoff waiting for it.  Once we have a conn, we break and
 	// then wait to read it.
@@ -555,12 +538,12 @@ func (v *MachineVM) connectToPodmanSocket(maxBackoffs int, backoff time.Duration
 			time.Sleep(backoff)
 			backoff *= 2
 		}
-		conn, dialErr = net.Dial("unix", filepath.Join(socketPath, "podman", v.Name+"_ready.sock"))
+		conn, dialErr = net.Dial("unix", path)
 		if dialErr == nil {
 			break
 		}
-		// check if qemu is still alive
-		err := checkProcessStatus("qemu", qemuPID, errBuf)
+		// check if qemu/gvproxy is still alive
+		err := checkProcessStatus(processName, pid, errBuf)
 		if err != nil {
 			return nil, err
 		}
@@ -589,7 +572,8 @@ func (v *MachineVM) qemuPid() (int, error) {
 		logrus.Warnf("Reading QEMU pidfile: %v", err)
 		return -1, nil
 	}
-	return findProcess(pid)
+
+	return pingProcess(pid)
 }
 
 // Start executes the qemu command line and forks it
@@ -597,6 +581,7 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 	var (
 		conn           net.Conn
 		err            error
+		fd             *os.File
 		qemuSocketConn net.Conn
 	)
 
@@ -658,11 +643,6 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 		logrus.Errorf("machine %q is incompatible with this release of podman and needs to be recreated, starting for recovery only", v.Name)
 	}
 
-	forwardSock, forwardState, err := v.startHostNetworking()
-	if err != nil {
-		return fmt.Errorf("unable to start host networking: %q", err)
-	}
-
 	rtPath, err := getRuntimeDir()
 	if err != nil {
 		return err
@@ -676,23 +656,57 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 		}
 	}
 
-	// If the qemusocketpath exists and the vm is off/down, we should rm
-	// it before the dial as to avoid a segv
-	if err := v.QMPMonitor.Address.Delete(); err != nil {
+	vlanSocket, err := machineSocket(v.Name, "vlan", "")
+	if err != nil {
 		return err
 	}
+	isFdVlanVM := false
+	for _, c := range v.CmdLine {
+		if c == fdVlanNetdev() {
+			isFdVlanVM = true
+		}
+	}
 
-	qemuSocketConn, err = v.connectToQMPMonitorSocket(maxBackoffs, defaultBackoff)
+	forwardSock, forwardState, forwarderProcess, err := v.startHostNetworking(vlanSocket)
 	if err != nil {
-		return err
+		return fmt.Errorf("unable to start host networking: %q", err)
 	}
-	defer qemuSocketConn.Close()
+	defer func() {
+		_ = vlanSocket.Delete()
+	}()
 
-	fd, err := qemuSocketConn.(*net.UnixConn).File()
-	if err != nil {
-		return err
+	if isFdVlanVM {
+		qemuSocketConn, err = v.connectToPodmanSocket(maxBackoffs, defaultBackoff, "gvproxy", forwarderProcess.Pid, nil, vlanSocket.GetPath())
+		if err != nil {
+			return err
+		}
+		defer qemuSocketConn.Close()
+
+		fd, err = qemuSocketConn.(*net.UnixConn).File()
+		if err != nil {
+			return err
+		}
+		defer fd.Close()
+	} else {
+		time.Sleep(defaultBackoff)
+		backoff := defaultBackoff
+		for i := 0; i < maxBackoffs; i++ {
+			if i > 0 {
+				time.Sleep(backoff)
+				backoff *= 2
+			}
+			// First need to verify that gvproxy is alive,
+			// because `.sock` file could belong to a different process
+			err := checkProcessStatus(machine.ForwarderBinaryName, forwarderProcess.Pid, nil)
+			if err != nil {
+				return err
+			}
+			_, err = os.Stat(vlanSocket.GetPath())
+			if err == nil {
+				break
+			}
+		}
 	}
-	defer fd.Close()
 
 	dnr, dnw, err := machine.GetDevNullFiles()
 	if err != nil {
@@ -702,7 +716,10 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 	defer dnw.Close()
 
 	attr := new(os.ProcAttr)
-	files := []*os.File{dnr, dnw, dnw, fd}
+	files := []*os.File{dnr, dnw, dnw}
+	if fd != nil {
+		files = append(files, fd)
+	}
 	attr.Files = files
 	cmdLine := v.CmdLine
 
@@ -720,12 +737,14 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 
 	// actually run the command that starts the virtual machine
 	cmd := &exec.Cmd{
-		Args:       cmdLine,
-		Path:       cmdLine[0],
-		Stdin:      dnr,
-		Stdout:     dnw,
-		Stderr:     stderrBuf,
-		ExtraFiles: []*os.File{fd},
+		Args:   cmdLine,
+		Path:   cmdLine[0],
+		Stdin:  dnr,
+		Stdout: dnw,
+		Stderr: stderrBuf,
+	}
+	if fd != nil {
+		cmd.ExtraFiles = []*os.File{fd}
 	}
 
 	if err := runStartVMCommand(cmd); err != nil {
@@ -737,7 +756,7 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 		fmt.Println("Waiting for VM ...")
 	}
 
-	conn, err = v.connectToPodmanSocket(maxBackoffs, defaultBackoff, cmd.Process.Pid, stderrBuf)
+	conn, err = v.connectToPodmanSocket(maxBackoffs, defaultBackoff, "qemu", cmd.Process.Pid, stderrBuf, v.ReadySocket.Path)
 	if err != nil {
 		return err
 	}
@@ -874,7 +893,7 @@ func (v *MachineVM) checkStatus(monitor *qmp.SocketMonitor) (machine.Status, err
 func (v *MachineVM) waitForMachineToStop() error {
 	fmt.Println("Waiting for VM to stop running...")
 	waitInternal := 250 * time.Millisecond
-	for i := 0; i < 5; i++ {
+	for i := 0; i < retryCountForStop; i++ {
 		state, err := v.State(false)
 		if err != nil {
 			return err
@@ -907,15 +926,14 @@ func (v *MachineVM) ProxyPID() (int, error) {
 	return proxyPid, nil
 }
 
-// cleanupVMProxyProcess kills the proxy process and removes the VM's pidfile
-func (v *MachineVM) cleanupVMProxyProcess(proxyProc *os.Process) error {
+// cleanupVMProxyProcess kills the proxy process
+func (v *MachineVM) cleanupVMProxyProcess(proxyPid int) error {
 	// Kill the process
-	if err := proxyProc.Kill(); err != nil {
+	if err := killProcess(proxyPid); err != nil {
 		return err
 	}
-	// Remove the pidfile
 	if err := v.PidFilePath.Delete(); err != nil {
-		return err
+		logrus.Debugf("Error while removing proxy pidfile: %v", err)
 	}
 	return nil
 }
@@ -962,7 +980,7 @@ func (v *MachineVM) Stop(_ string, _ machine.StopOptions) error {
 		return stopErr
 	}
 
-	if err := sigKill(qemuPid); err != nil {
+	if err := killProcess(qemuPid); err != nil {
 		if stopErr == nil {
 			return err
 		}
@@ -1037,7 +1055,7 @@ func (v *MachineVM) stopLocked() error {
 		return err
 	}
 
-	if err := v.cleanupVMProxyProcess(proxyProc); err != nil {
+	if err := v.cleanupVMProxyProcess(proxyPid); err != nil {
 		return err
 	}
 
@@ -1069,7 +1087,11 @@ func (v *MachineVM) stopLocked() error {
 	}
 
 	fmt.Println("Waiting for VM to exit...")
-	for isProcessAlive(vmPid) {
+	for {
+		alive, _ := isProcessAlive(vmPid)
+		if !alive {
+			break
+		}
 		time.Sleep(500 * time.Millisecond)
 	}
 
@@ -1078,32 +1100,42 @@ func (v *MachineVM) stopLocked() error {
 
 // NewQMPMonitor creates the monitor subsection of our vm
 func NewQMPMonitor(network, name string, timeout time.Duration) (Monitor, error) {
-	rtDir, err := getRuntimeDir()
+	if timeout == 0 {
+		timeout = defaultQMPTimeout
+	}
+	address, err := machineSocket(name, "qmp", "")
 	if err != nil {
 		return Monitor{}, err
 	}
+	monitor := Monitor{
+		Network: network,
+		Address: *address,
+		Timeout: timeout,
+	}
+	return monitor, nil
+}
+
+func machineSocket(name, prefix, suffix string) (*machine.VMFile, error) {
+	rtDir, err := getRuntimeDir()
+	if err != nil {
+		return nil, err
+	}
 	if isRootful() {
 		rtDir = "/run"
 	}
 	rtDir = filepath.Join(rtDir, "podman")
 	if _, err := os.Stat(rtDir); errors.Is(err, fs.ErrNotExist) {
 		if err := os.MkdirAll(rtDir, 0755); err != nil {
-			return Monitor{}, err
+			return nil, err
 		}
 	}
-	if timeout == 0 {
-		timeout = defaultQMPTimeout
+	if prefix != "" {
+		name = prefix + "_" + name
 	}
-	address, err := machine.NewMachineFile(filepath.Join(rtDir, "qmp_"+name+".sock"), nil)
-	if err != nil {
-		return Monitor{}, err
-	}
-	monitor := Monitor{
-		Network: network,
-		Address: *address,
-		Timeout: timeout,
+	if suffix != "" {
+		name = name + "_" + suffix
 	}
-	return monitor, nil
+	return machine.NewMachineFile(filepath.Join(rtDir, name+".sock"), nil)
 }
 
 // collectFilesToDestroy retrieves the files that will be destroyed by `Remove`
@@ -1307,18 +1339,18 @@ func getDiskSize(path string) (uint64, error) {
 
 // startHostNetworking runs a binary on the host system that allows users
 // to set up port forwarding to the podman virtual machine
-func (v *MachineVM) startHostNetworking() (string, machine.APIForwardingState, error) {
+func (v *MachineVM) startHostNetworking(vlanSocket *machine.VMFile) (string, machine.APIForwardingState, *os.Process, error) {
 	cfg, err := config.Default()
 	if err != nil {
-		return "", machine.NoForwarding, err
+		return "", machine.NoForwarding, nil, err
 	}
 	binary, err := cfg.FindHelperBinary(machine.ForwarderBinaryName, false)
 	if err != nil {
-		return "", machine.NoForwarding, err
+		return "", machine.NoForwarding, nil, err
 	}
 
 	cmd := gvproxy.NewGvproxyCommand()
-	cmd.AddQemuSocket(fmt.Sprintf("unix://%s", v.QMPMonitor.Address.GetPath()))
+	cmd.AddQemuSocket(fmt.Sprintf("unix://%s", strings.ReplaceAll(vlanSocket.GetPath(), "\\", "/")))
 	cmd.PidFile = v.PidFilePath.GetPath()
 	cmd.SSHPort = v.Port
 
@@ -1333,11 +1365,13 @@ func (v *MachineVM) startHostNetworking() (string, machine.APIForwardingState, e
 		logrus.Debug(cmd)
 	}
 
+	cargs := cmd.ToCmdline()
+	logrus.Debugf("gvproxy cmd: %v", append([]string{binary}, cargs...))
 	c := cmd.Cmd(binary)
 	if err := c.Start(); err != nil {
-		return "", 0, fmt.Errorf("unable to execute: %q: %w", cmd.ToCmdline(), err)
+		return "", 0, nil, fmt.Errorf("unable to execute: %q: %w", cmd.ToCmdline(), err)
 	}
-	return forwardSock, state, nil
+	return forwardSock, state, c.Process, nil
 }
 
 func (v *MachineVM) setupAPIForwarding(cmd gvproxy.GvproxyCommand) (gvproxy.GvproxyCommand, string, machine.APIForwardingState) {
@@ -1355,10 +1389,10 @@ func (v *MachineVM) setupAPIForwarding(cmd gvproxy.GvproxyCommand) (gvproxy.Gvpr
 		forwardUser = "root"
 	}
 
-	cmd.AddForwardSock(socket.GetPath())
-	cmd.AddForwardDest(destSock)
-	cmd.AddForwardUser(forwardUser)
-	cmd.AddForwardIdentity(v.IdentityPath)
+	err = forwardSocketArgs(&cmd, v.Name, socket.GetPath(), destSock, v.IdentityPath, forwardUser)
+	if err != nil {
+		return cmd, "", machine.NoForwarding
+	}
 
 	// The linking pattern is /var/run/docker.sock -> user global sock (link) -> machine sock (socket)
 	// This allows the helper to only have to maintain one constant target to the user, which can be
@@ -1568,6 +1602,7 @@ func (v *MachineVM) Inspect() (*machine.InspectInfo, error) {
 		return nil, err
 	}
 	connInfo.PodmanSocket = podmanSocket
+	connInfo.PodmanPipe = podmanPipe(v.Name)
 	return &machine.InspectInfo{
 		ConfigPath:         v.ConfigPath,
 		ConnectionInfo:     *connInfo,
@@ -1634,6 +1669,18 @@ func (v *MachineVM) editCmdLine(flag string, value string) {
 	}
 }
 
+func forwardSocketArgs(cmd *gvproxy.GvproxyCommand, name string, path string, destPath string, identityPath string, user string) error {
+	err := forwardPipeArgs(cmd, name, destPath, identityPath, user)
+	if err != nil {
+		return err
+	}
+	cmd.AddForwardSock(path)
+	cmd.AddForwardDest(destPath)
+	cmd.AddForwardUser(user)
+	cmd.AddForwardIdentity(identityPath)
+	return nil
+}
+
 func isRootful() bool {
 	// Rootless is not relevant on Windows. In the future rootless.IsRootless
 	// could be switched to return true on Windows, and other codepaths migrated
diff --git a/pkg/machine/qemu/machine_unix.go b/pkg/machine/qemu/machine_unix.go
index e764013d8..34fa9f44c 100644
--- a/pkg/machine/qemu/machine_unix.go
+++ b/pkg/machine/qemu/machine_unix.go
@@ -6,25 +6,43 @@ package qemu
 import (
 	"bytes"
 	"fmt"
+	"os"
 	"strings"
 	"syscall"
 
+	gvproxy "github.com/containers/gvisor-tap-vsock/pkg/types"
+	"github.com/containers/podman/v4/pkg/machine"
 	"golang.org/x/sys/unix"
 )
 
-func isProcessAlive(pid int) bool {
+func isProcessAlive(pid int) (bool, error) {
 	err := unix.Kill(pid, syscall.Signal(0))
 	if err == nil || err == unix.EPERM {
-		return true
+		return true, nil
 	}
-	return false
+	return false, err
+}
+
+func pingProcess(pid int) (int, error) {
+	alive, err := isProcessAlive(pid)
+	if !alive {
+		if err == unix.ESRCH {
+			return -1, nil
+		}
+		return -1, fmt.Errorf("pinging QEMU process: %w", err)
+	}
+	return pid, nil
+}
+
+func killProcess(pid int) error {
+	return unix.Kill(pid, unix.SIGKILL)
 }
 
 func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) error {
 	var status syscall.WaitStatus
 	pid, err := syscall.Wait4(pid, &status, syscall.WNOHANG, nil)
 	if err != nil {
-		return fmt.Errorf("failed to read qem%su process status: %w", processHint, err)
+		return fmt.Errorf("failed to read %s process status: %w", processHint, err)
 	}
 	if pid > 0 {
 		// child exited
@@ -33,6 +51,18 @@ func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) er
 	return nil
 }
 
+func forwardPipeArgs(cmd *gvproxy.GvproxyCommand, name string, destPath string, identityPath string, user string) error {
+	return nil
+}
+
+func podmanPipe(name string) *machine.VMFile {
+	return nil
+}
+
+func useFdVLan() bool {
+	return strings.ToUpper(os.Getenv("CONTAINERS_USE_SOCKET_VLAN")) != "TRUE"
+}
+
 func pathsFromVolume(volume string) []string {
 	return strings.SplitN(volume, ":", 3)
 }
@@ -43,17 +73,3 @@ func extractTargetPath(paths []string) string {
 	}
 	return paths[0]
 }
-
-func sigKill(pid int) error {
-	return unix.Kill(pid, unix.SIGKILL)
-}
-
-func findProcess(pid int) (int, error) {
-	if err := unix.Kill(pid, 0); err != nil {
-		if err == unix.ESRCH {
-			return -1, nil
-		}
-		return -1, fmt.Errorf("pinging QEMU process: %w", err)
-	}
-	return pid, nil
-}
diff --git a/pkg/machine/qemu/machine_windows.go b/pkg/machine/qemu/machine_windows.go
index b31a4f1d1..76a6a1ab1 100644
--- a/pkg/machine/qemu/machine_windows.go
+++ b/pkg/machine/qemu/machine_windows.go
@@ -6,14 +6,28 @@ import (
 	"regexp"
 	"strings"
 
+	gvproxy "github.com/containers/gvisor-tap-vsock/pkg/types"
 	"github.com/containers/podman/v4/pkg/machine"
 )
 
-func isProcessAlive(pid int) bool {
+func isProcessAlive(pid int) (bool, error) {
 	if checkProcessStatus("process", pid, nil) == nil {
-		return true
+		return true, nil
 	}
-	return false
+	return false, nil
+}
+
+func pingProcess(pid int) (int, error) {
+	alive, _ := isProcessAlive(pid)
+	if !alive {
+		return -1, nil
+	}
+	return pid, nil
+}
+
+func killProcess(pid int) error {
+	machine.SendQuit(uint32(pid))
+	return nil
 }
 
 func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) error {
@@ -28,6 +42,36 @@ func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) er
 	return nil
 }
 
+func forwardPipeArgs(cmd *gvproxy.GvproxyCommand, name string, destPath string, identityPath string, user string) error {
+	machinePipe := toPipeName(name)
+	if !machine.PipeNameAvailable(machinePipe) {
+		return fmt.Errorf("could not start api proxy since expected pipe is not available: %s", machinePipe)
+	}
+	cmd.AddForwardSock(fmt.Sprintf("npipe:////./pipe/%s", machinePipe))
+	cmd.AddForwardDest(destPath)
+	cmd.AddForwardUser(user)
+	cmd.AddForwardIdentity(identityPath)
+	return nil
+}
+
+func podmanPipe(name string) *machine.VMFile {
+	return &machine.VMFile{Path: `\\.\pipe\` + toPipeName(name)}
+}
+
+func toPipeName(name string) string {
+	if !strings.HasPrefix(name, "qemu-podman") {
+		if !strings.HasPrefix(name, "podman") {
+			name = "podman-" + name
+		}
+		name = "qemu-" + name
+	}
+	return name
+}
+
+func useFdVLan() bool {
+	return false
+}
+
 func pathsFromVolume(volume string) []string {
 	paths := strings.SplitN(volume, ":", 3)
 	driveLetterMatcher := regexp.MustCompile(`^(?:\\\\[.?]\\)?[a-zA-Z]$`)
@@ -50,11 +94,3 @@ func extractTargetPath(paths []string) string {
 	dedup := regexp.MustCompile(`//+`)
 	return dedup.ReplaceAllLiteralString("/"+target, "/")
 }
-
-func sigKill(pid int) error {
-	return nil
-}
-
-func findProcess(pid int) (int, error) {
-	return -1, nil
-}
diff --git a/pkg/machine/wsl/machine.go b/pkg/machine/wsl/machine.go
index 38219a799..197d9510a 100644
--- a/pkg/machine/wsl/machine.go
+++ b/pkg/machine/wsl/machine.go
@@ -1481,7 +1481,7 @@ func stopWinProxy(v *MachineVM) error {
 	if err != nil {
 		return nil
 	}
-	sendQuit(tid)
+	machine.SendQuit(tid)
 	_ = waitTimeout(proc, 20*time.Second)
 	_ = os.Remove(tidFile)
 
diff --git a/pkg/machine/wsl/util_windows.go b/pkg/machine/wsl/util_windows.go
index fac85f9b9..b7a7b0661 100644
--- a/pkg/machine/wsl/util_windows.go
+++ b/pkg/machine/wsl/util_windows.go
@@ -68,7 +68,6 @@ const (
 	TOKEN_QUERY                     = 0x0008
 	SE_PRIVILEGE_ENABLED            = 0x00000002
 	SE_ERR_ACCESSDENIED             = 0x05
-	WM_QUIT                         = 0x12
 )
 
 func winVersionAtLeast(major uint, minor uint, build uint) bool {
@@ -338,9 +337,3 @@ func buildCommandArgs(elevate bool) string {
 	}
 	return strings.Join(args, " ")
 }
-
-func sendQuit(tid uint32) {
-	user32 := syscall.NewLazyDLL("user32.dll")
-	postMessage := user32.NewProc("PostThreadMessageW")
-	postMessage.Call(uintptr(tid), WM_QUIT, 0, 0)
-}
-- 
2.42.0

