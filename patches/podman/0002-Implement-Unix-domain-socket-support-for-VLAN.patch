From 864f320eeb94ffd596888cddf5ebc25b0554e6dd Mon Sep 17 00:00:00 2001
From: Arthur Sengileyev <arthur.sengileyev@gmail.com>
Date: Tue, 26 Sep 2023 14:52:38 +0300
Subject: [PATCH 2/3] Implement Unix domain socket support for VLAN

This change adds support for new QEMU stream netdev added in 7.2.0.
It is implemented as an opt-in mode for previously supported
platforms and the only supported mode on Windows.

Old FD netdev has changes only on podman side. Instead of previously
used QMP socket address, it now has VLAN dedicated socket address to
make both implementations more similar.

As VLAN socket address has short lifespan (it exists only after
forwarder has been started and before QEMU has finished startup),
it is not promoted to persisted machine settings, but is rather
calculated inside Start method.

Signed-off-by: Arthur Sengileyev <arthur.sengileyev@gmail.com>
---
 pkg/machine/e2e/README.md             |  23 ++++
 pkg/machine/machine_windows.go        |  11 ++
 pkg/machine/qemu/command.go           |  23 +++-
 pkg/machine/qemu/config.go            |  11 +-
 pkg/machine/qemu/machine.go           | 177 ++++++++++++++++++--------
 pkg/machine/qemu/machine_unix.go      |  56 +++++---
 pkg/machine/qemu/machine_windows.go   |  59 +++++++--
 pkg/machine/qemu/qemu_command_test.go |   3 +-
 pkg/machine/wsl/machine.go            |   2 +-
 pkg/machine/wsl/util_windows.go       |   7 -
 10 files changed, 275 insertions(+), 97 deletions(-)

diff --git a/pkg/machine/e2e/README.md b/pkg/machine/e2e/README.md
index 7b0637a1d..c33d44e07 100644
--- a/pkg/machine/e2e/README.md
+++ b/pkg/machine/e2e/README.md
@@ -40,3 +40,26 @@ Note: To run specific test files, add the test files to the end of the winmake c
 1. `./test/tools/build/ginkgo -vv  --tags "remote exclude_graphdriver_btrfs btrfs_noversion exclude_graphdriver_devicemapper containers_image_openpgp remote" -timeout=90m --trace --no-color  pkg/machine/e2e/.`
 
 Note: Add `--focus-file "basic_test.go" ` to only run basic test
+
+### QEMU (fd vlan)
+
+1. Install QEMU `brew install qemu`
+1. Install Podman (needed to have gvproxy binary) `brew install podman`
+1. `make podman-remote`
+1. `make .install.ginkgo`
+1. `export TMPDIR=/Users/<yourname>`
+1. `./test/tools/build/ginkgo -vv  --tags "remote exclude_graphdriver_btrfs btrfs_noversion exclude_graphdriver_devicemapper containers_image_openpgp remote" -timeout=90m --trace --no-color  pkg/machine/e2e/.`
+
+Note: Add `--focus-file "basic_test.go" ` to only run basic test
+
+### QEMU (UNIX domain socket vlan)
+
+1. Install QEMU `brew install qemu`
+1. Install Podman (needed to have gvproxy binary) `brew install podman`
+1. `make podman-remote`
+1. `make .install.ginkgo`
+1. `export TMPDIR=/Users/<yourname>`
+1. `export CONTAINERS_USE_SOCKET_VLAN=true`
+1. `./test/tools/build/ginkgo -vv  --tags "remote exclude_graphdriver_btrfs btrfs_noversion exclude_graphdriver_devicemapper containers_image_openpgp remote" -timeout=90m --trace --no-color  pkg/machine/e2e/.`
+
+Note: Add `--focus-file "basic_test.go" ` to only run basic test
diff --git a/pkg/machine/machine_windows.go b/pkg/machine/machine_windows.go
index fe1d2fa5c..c4cf08d2c 100644
--- a/pkg/machine/machine_windows.go
+++ b/pkg/machine/machine_windows.go
@@ -11,6 +11,17 @@ import (
 	"github.com/sirupsen/logrus"
 )
 
+// nolint // Cleaner to refer to the official OS constant names, and consistent with syscall
+const (
+	WM_QUIT = 0x12
+)
+
+func SendQuit(tid uint32) {
+	user32 := syscall.NewLazyDLL("user32.dll")
+	postMessage := user32.NewProc("PostThreadMessageW")
+	postMessage.Call(uintptr(tid), WM_QUIT, 0, 0)
+}
+
 func GetProcessState(pid int) (active bool, exitCode int) {
 	const da = syscall.STANDARD_RIGHTS_READ | syscall.PROCESS_QUERY_INFORMATION | syscall.SYNCHRONIZE
 	handle, err := syscall.OpenProcess(da, false, uint32(pid))
diff --git a/pkg/machine/qemu/command.go b/pkg/machine/qemu/command.go
index c8dc31510..82e701888 100644
--- a/pkg/machine/qemu/command.go
+++ b/pkg/machine/qemu/command.go
@@ -41,10 +41,29 @@ func (q *QemuCmd) SetQmpMonitor(monitor Monitor) {
 }
 
 // SetNetwork adds a network device to the machine
-func (q *QemuCmd) SetNetwork() {
+func (q *QemuCmd) SetNetwork(name string) error {
 	// Right now the mac address is hardcoded so that the host networking gives it a specific IP address.  This is
 	// why we can only run one vm at a time right now
-	*q = append(*q, "-netdev", "socket,id=vlan,fd=3", "-device", "virtio-net-pci,netdev=vlan,mac=5a:94:ef:e4:0c:ee")
+	if useFdVLan() {
+		*q = append(*q, []string{"-netdev", fdVlanNetdev()}...)
+	} else {
+		vlanSocket, err := machineSocket(name, "vlan", "")
+		if err != nil {
+			return err
+		} else {
+			*q = append(*q, []string{"-netdev", socketVlanNetdev(vlanSocket.GetPath())}...)
+		}
+	}
+	*q = append(*q, []string{"-device", "virtio-net-pci,netdev=vlan,mac=5a:94:ef:e4:0c:ee"}...)
+	return nil
+}
+
+func fdVlanNetdev() string {
+	return "socket,id=vlan,fd=3"
+}
+
+func socketVlanNetdev(path string) string {
+	return fmt.Sprintf("stream,id=vlan,server=off,addr.type=unix,addr.path=%s", path)
 }
 
 // SetNetwork adds a network device to the machine
diff --git a/pkg/machine/qemu/config.go b/pkg/machine/qemu/config.go
index 25d5af5e7..a14ef41dd 100644
--- a/pkg/machine/qemu/config.go
+++ b/pkg/machine/qemu/config.go
@@ -58,15 +58,18 @@ func (v *MachineVM) setQMPMonitorSocket() error {
 
 // setNewMachineCMD configure the CLI command that will be run to create the new
 // machine
-func (v *MachineVM) setNewMachineCMD(qemuBinary string, cmdOpts *setNewMachineCMDOpts) {
+func (v *MachineVM) setNewMachineCMD(qemuBinary string, cmdOpts *setNewMachineCMDOpts) error {
 	v.CmdLine = NewQemuBuilder(qemuBinary, v.addArchOptions(cmdOpts))
 	v.CmdLine.SetMemory(v.Memory)
 	v.CmdLine.SetCPUs(v.CPUs)
 	v.CmdLine.SetIgnitionFile(v.IgnitionFile)
 	v.CmdLine.SetQmpMonitor(v.QMPMonitor)
-	v.CmdLine.SetNetwork()
+	if err := v.CmdLine.SetNetwork(v.Name); err != nil {
+		return err
+	}
 	v.CmdLine.SetSerialPort(v.ReadySocket, v.VMPidFilePath, v.Name)
 	v.CmdLine.SetUSBHostPassthrough(v.USBs)
+	return nil
 }
 
 func parseUSBs(usbs []string) ([]machine.USBConfig, error) {
@@ -201,7 +204,9 @@ func (p *QEMUVirtualization) NewMachine(opts machine.InitOptions) (machine.VM, e
 
 	// configure command to run
 	cmdOpts := setNewMachineCMDOpts{imageDir: dataDir}
-	vm.setNewMachineCMD(execPath, &cmdOpts)
+	if err := vm.setNewMachineCMD(execPath, &cmdOpts); err != nil {
+		return nil, err
+	}
 	return vm, nil
 }
 
diff --git a/pkg/machine/qemu/machine.go b/pkg/machine/qemu/machine.go
index dac5b1a87..49e46737e 100644
--- a/pkg/machine/qemu/machine.go
+++ b/pkg/machine/qemu/machine.go
@@ -43,6 +43,7 @@ const (
 	MountType9p          = "9p"
 	dockerSock           = "/var/run/docker.sock"
 	dockerConnectTimeout = 5 * time.Second
+	retryCountForStop    = 5
 )
 
 // qemuReadyUnit is a unit file that sets up the virtual serial device
@@ -168,6 +169,9 @@ func (v *MachineVM) Init(opts machine.InitOptions) (bool, error) {
 	}
 
 	v.UID = os.Getuid()
+	if v.UID == -1 {
+		v.UID = 501 // Used on Windows to match FCOS image
+	}
 
 	// Add location of bootable image
 	v.CmdLine.SetBootableImage(v.getImageFile())
@@ -447,7 +451,8 @@ func (v *MachineVM) qemuPid() (int, error) {
 		logrus.Warnf("Reading QEMU pidfile: %v", err)
 		return -1, nil
 	}
-	return findProcess(pid)
+
+	return pingProcess(pid)
 }
 
 // Start executes the qemu command line and forks it
@@ -455,6 +460,7 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 	var (
 		conn           net.Conn
 		err            error
+		fd             *os.File
 		qemuSocketConn net.Conn
 	)
 
@@ -513,11 +519,6 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 		logrus.Errorf("machine %q is incompatible with this release of podman and needs to be recreated, starting for recovery only", v.Name)
 	}
 
-	forwardSock, forwardState, err := v.startHostNetworking()
-	if err != nil {
-		return fmt.Errorf("unable to start host networking: %q", err)
-	}
-
 	rtPath, err := getRuntimeDir()
 	if err != nil {
 		return err
@@ -531,23 +532,58 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 		}
 	}
 
-	// If the qemusocketpath exists and the vm is off/down, we should rm
-	// it before the dial as to avoid a segv
-	if err := v.QMPMonitor.Address.Delete(); err != nil {
+	vlanSocket, err := machineSocket(v.Name, "vlan", "")
+	if err != nil {
 		return err
 	}
-
-	qemuSocketConn, err = machine.DialSocketWithBackoffs(maxBackoffs, defaultBackoff, v.QMPMonitor.Address.Path)
+	err = vlanSocket.Delete()
 	if err != nil {
 		return err
 	}
-	defer qemuSocketConn.Close()
+	isFdVlanVM := false
+	for _, c := range v.CmdLine {
+		if c == fdVlanNetdev() {
+			isFdVlanVM = true
+		}
+	}
 
-	fd, err := qemuSocketConn.(*net.UnixConn).File()
+	forwardSock, forwardState, forwarderProcess, err := v.startHostNetworking(vlanSocket)
 	if err != nil {
-		return err
+		return fmt.Errorf("unable to start host networking: %q", err)
+	}
+
+	if isFdVlanVM {
+		qemuSocketConn, err = machine.DialSocketWithBackoffs(maxBackoffs, defaultBackoff, vlanSocket.GetPath())
+		if err != nil {
+			return err
+		}
+		defer qemuSocketConn.Close()
+
+		fd, err = qemuSocketConn.(*net.UnixConn).File()
+		if err != nil {
+			return err
+		}
+		defer fd.Close()
+	} else {
+		time.Sleep(defaultBackoff)
+		backoff := defaultBackoff
+		for i := 0; i < maxBackoffs; i++ {
+			if i > 0 {
+				time.Sleep(backoff)
+				backoff *= 2
+			}
+			// First need to verify that gvproxy is alive,
+			// because `.sock` file could belong to a different process
+			err := checkProcessStatus(machine.ForwarderBinaryName, forwarderProcess.Pid, nil)
+			if err != nil {
+				return err
+			}
+			_, err = os.Stat(vlanSocket.GetPath())
+			if err == nil {
+				break
+			}
+		}
 	}
-	defer fd.Close()
 
 	dnr, dnw, err := machine.GetDevNullFiles()
 	if err != nil {
@@ -557,7 +593,10 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 	defer dnw.Close()
 
 	attr := new(os.ProcAttr)
-	files := []*os.File{dnr, dnw, dnw, fd}
+	files := []*os.File{dnr, dnw, dnw}
+	if fd != nil {
+		files = append(files, fd)
+	}
 	attr.Files = files
 	cmdLine := v.CmdLine
 
@@ -575,12 +614,14 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 
 	// actually run the command that starts the virtual machine
 	cmd := &exec.Cmd{
-		Args:       cmdLine,
-		Path:       cmdLine[0],
-		Stdin:      dnr,
-		Stdout:     dnw,
-		Stderr:     stderrBuf,
-		ExtraFiles: []*os.File{fd},
+		Args:   cmdLine,
+		Path:   cmdLine[0],
+		Stdin:  dnr,
+		Stdout: dnw,
+		Stderr: stderrBuf,
+	}
+	if fd != nil {
+		cmd.ExtraFiles = []*os.File{fd}
 	}
 
 	if err := runStartVMCommand(cmd); err != nil {
@@ -729,7 +770,7 @@ func (v *MachineVM) checkStatus(monitor *qmp.SocketMonitor) (machine.Status, err
 func (v *MachineVM) waitForMachineToStop() error {
 	fmt.Println("Waiting for VM to stop running...")
 	waitInternal := 250 * time.Millisecond
-	for i := 0; i < 5; i++ {
+	for i := 0; i < retryCountForStop; i++ {
 		state, err := v.State(false)
 		if err != nil {
 			return err
@@ -762,15 +803,14 @@ func (v *MachineVM) ProxyPID() (int, error) {
 	return proxyPid, nil
 }
 
-// cleanupVMProxyProcess kills the proxy process and removes the VM's pidfile
-func (v *MachineVM) cleanupVMProxyProcess(proxyProc *os.Process) error {
+// cleanupVMProxyProcess kills the proxy process
+func (v *MachineVM) cleanupVMProxyProcess(proxyPid int) error {
 	// Kill the process
-	if err := proxyProc.Kill(); err != nil {
+	if err := killProcess(proxyPid, false); err != nil {
 		return err
 	}
-	// Remove the pidfile
 	if err := v.PidFilePath.Delete(); err != nil {
-		return err
+		logrus.Debugf("Error while removing proxy pidfile: %v", err)
 	}
 	return nil
 }
@@ -814,7 +854,7 @@ func (v *MachineVM) Stop(_ string, _ machine.StopOptions) error {
 		return stopErr
 	}
 
-	if err := sigKill(qemuPid); err != nil {
+	if err := killProcess(qemuPid, true); err != nil {
 		if stopErr == nil {
 			return err
 		}
@@ -889,7 +929,7 @@ func (v *MachineVM) stopLocked() error {
 		return err
 	}
 
-	if err := v.cleanupVMProxyProcess(proxyProc); err != nil {
+	if err := v.cleanupVMProxyProcess(proxyPid); err != nil {
 		return err
 	}
 
@@ -921,7 +961,11 @@ func (v *MachineVM) stopLocked() error {
 	}
 
 	fmt.Println("Waiting for VM to exit...")
-	for isProcessAlive(vmPid) {
+	for {
+		alive, _ := isProcessAlive(vmPid)
+		if !alive {
+			break
+		}
 		time.Sleep(500 * time.Millisecond)
 	}
 
@@ -930,32 +974,42 @@ func (v *MachineVM) stopLocked() error {
 
 // NewQMPMonitor creates the monitor subsection of our vm
 func NewQMPMonitor(network, name string, timeout time.Duration) (Monitor, error) {
-	rtDir, err := getRuntimeDir()
+	if timeout == 0 {
+		timeout = defaultQMPTimeout
+	}
+	address, err := machineSocket(name, "qmp", "")
 	if err != nil {
 		return Monitor{}, err
 	}
+	monitor := Monitor{
+		Network: network,
+		Address: *address,
+		Timeout: timeout,
+	}
+	return monitor, nil
+}
+
+func machineSocket(name, prefix, suffix string) (*define.VMFile, error) {
+	rtDir, err := getRuntimeDir()
+	if err != nil {
+		return nil, err
+	}
 	if isRootful() {
 		rtDir = "/run"
 	}
 	rtDir = filepath.Join(rtDir, "podman")
 	if _, err := os.Stat(rtDir); errors.Is(err, fs.ErrNotExist) {
 		if err := os.MkdirAll(rtDir, 0755); err != nil {
-			return Monitor{}, err
+			return nil, err
 		}
 	}
-	if timeout == 0 {
-		timeout = defaultQMPTimeout
+	if prefix != "" {
+		name = prefix + "_" + name
 	}
-	address, err := define.NewMachineFile(filepath.Join(rtDir, "qmp_"+name+".sock"), nil)
-	if err != nil {
-		return Monitor{}, err
+	if suffix != "" {
+		name = name + "_" + suffix
 	}
-	monitor := Monitor{
-		Network: network,
-		Address: *address,
-		Timeout: timeout,
-	}
-	return monitor, nil
+	return define.NewMachineFile(filepath.Join(rtDir, name+".sock"), nil)
 }
 
 // collectFilesToDestroy retrieves the files that will be destroyed by `Remove`
@@ -1156,18 +1210,18 @@ func getDiskSize(path string) (uint64, error) {
 
 // startHostNetworking runs a binary on the host system that allows users
 // to set up port forwarding to the podman virtual machine
-func (v *MachineVM) startHostNetworking() (string, machine.APIForwardingState, error) {
+func (v *MachineVM) startHostNetworking(vlanSocket *define.VMFile) (string, machine.APIForwardingState, *os.Process, error) {
 	cfg, err := config.Default()
 	if err != nil {
-		return "", machine.NoForwarding, err
+		return "", machine.NoForwarding, nil, err
 	}
 	binary, err := cfg.FindHelperBinary(machine.ForwarderBinaryName, false)
 	if err != nil {
-		return "", machine.NoForwarding, err
+		return "", machine.NoForwarding, nil, err
 	}
 
 	cmd := gvproxy.NewGvproxyCommand()
-	cmd.AddQemuSocket(fmt.Sprintf("unix://%s", v.QMPMonitor.Address.GetPath()))
+	cmd.AddQemuSocket(fmt.Sprintf("unix://%s", filepath.ToSlash(vlanSocket.GetPath())))
 	cmd.PidFile = v.PidFilePath.GetPath()
 	cmd.SSHPort = v.Port
 
@@ -1182,11 +1236,13 @@ func (v *MachineVM) startHostNetworking() (string, machine.APIForwardingState, e
 		logrus.Debug(cmd)
 	}
 
+	cargs := cmd.ToCmdline()
+	logrus.Debugf("gvproxy cmd: %v", append([]string{binary}, cargs...))
 	c := cmd.Cmd(binary)
 	if err := c.Start(); err != nil {
-		return "", 0, fmt.Errorf("unable to execute: %q: %w", cmd.ToCmdline(), err)
+		return "", 0, nil, fmt.Errorf("unable to execute: %q: %w", cmd.ToCmdline(), err)
 	}
-	return forwardSock, state, nil
+	return forwardSock, state, c.Process, nil
 }
 
 func (v *MachineVM) setupAPIForwarding(cmd gvproxy.GvproxyCommand) (gvproxy.GvproxyCommand, string, machine.APIForwardingState) {
@@ -1204,10 +1260,10 @@ func (v *MachineVM) setupAPIForwarding(cmd gvproxy.GvproxyCommand) (gvproxy.Gvpr
 		forwardUser = "root"
 	}
 
-	cmd.AddForwardSock(socket.GetPath())
-	cmd.AddForwardDest(destSock)
-	cmd.AddForwardUser(forwardUser)
-	cmd.AddForwardIdentity(v.IdentityPath)
+	err = forwardSocketArgs(&cmd, v.Name, socket.GetPath(), destSock, v.IdentityPath, forwardUser)
+	if err != nil {
+		return cmd, "", machine.NoForwarding
+	}
 
 	// The linking pattern is /var/run/docker.sock -> user global sock (link) -> machine sock (socket)
 	// This allows the helper to only have to maintain one constant target to the user, which can be
@@ -1380,6 +1436,7 @@ func (v *MachineVM) Inspect() (*machine.InspectInfo, error) {
 		return nil, err
 	}
 	connInfo.PodmanSocket = podmanSocket
+	connInfo.PodmanPipe = podmanPipe(v.Name)
 	return &machine.InspectInfo{
 		ConfigPath:         v.ConfigPath,
 		ConnectionInfo:     *connInfo,
@@ -1446,6 +1503,18 @@ func (v *MachineVM) editCmdLine(flag string, value string) {
 	}
 }
 
+func forwardSocketArgs(cmd *gvproxy.GvproxyCommand, name string, path string, destPath string, identityPath string, user string) error {
+	err := forwardPipeArgs(cmd, name, destPath, identityPath, user)
+	if err != nil {
+		return err
+	}
+	cmd.AddForwardSock(path)
+	cmd.AddForwardDest(destPath)
+	cmd.AddForwardUser(user)
+	cmd.AddForwardIdentity(identityPath)
+	return nil
+}
+
 func isRootful() bool {
 	// Rootless is not relevant on Windows. In the future rootless.IsRootless
 	// could be switched to return true on Windows, and other codepaths migrated
diff --git a/pkg/machine/qemu/machine_unix.go b/pkg/machine/qemu/machine_unix.go
index e764013d8..ef47b94df 100644
--- a/pkg/machine/qemu/machine_unix.go
+++ b/pkg/machine/qemu/machine_unix.go
@@ -6,25 +6,47 @@ package qemu
 import (
 	"bytes"
 	"fmt"
+	"os"
 	"strings"
 	"syscall"
 
+	gvproxy "github.com/containers/gvisor-tap-vsock/pkg/types"
+	"github.com/containers/podman/v4/pkg/machine/define"
 	"golang.org/x/sys/unix"
 )
 
-func isProcessAlive(pid int) bool {
+func isProcessAlive(pid int) (bool, error) {
 	err := unix.Kill(pid, syscall.Signal(0))
 	if err == nil || err == unix.EPERM {
-		return true
+		return true, nil
+	}
+	return false, err
+}
+
+func pingProcess(pid int) (int, error) {
+	alive, err := isProcessAlive(pid)
+	if !alive {
+		if err == unix.ESRCH {
+			return -1, nil
+		}
+		return -1, fmt.Errorf("pinging QEMU process: %w", err)
+	}
+	return pid, nil
+}
+
+func killProcess(pid int, force bool) error {
+	if force {
+		return unix.Kill(pid, unix.SIGKILL)
+	} else {
+		return unix.Kill(pid, unix.SIGTERM)
 	}
-	return false
 }
 
 func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) error {
 	var status syscall.WaitStatus
 	pid, err := syscall.Wait4(pid, &status, syscall.WNOHANG, nil)
 	if err != nil {
-		return fmt.Errorf("failed to read qem%su process status: %w", processHint, err)
+		return fmt.Errorf("failed to read %s process status: %w", processHint, err)
 	}
 	if pid > 0 {
 		// child exited
@@ -33,6 +55,18 @@ func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) er
 	return nil
 }
 
+func forwardPipeArgs(cmd *gvproxy.GvproxyCommand, name string, destPath string, identityPath string, user string) error {
+	return nil
+}
+
+func podmanPipe(name string) *define.VMFile {
+	return nil
+}
+
+func useFdVLan() bool {
+	return strings.ToUpper(os.Getenv("CONTAINERS_USE_SOCKET_VLAN")) != "TRUE"
+}
+
 func pathsFromVolume(volume string) []string {
 	return strings.SplitN(volume, ":", 3)
 }
@@ -43,17 +77,3 @@ func extractTargetPath(paths []string) string {
 	}
 	return paths[0]
 }
-
-func sigKill(pid int) error {
-	return unix.Kill(pid, unix.SIGKILL)
-}
-
-func findProcess(pid int) (int, error) {
-	if err := unix.Kill(pid, 0); err != nil {
-		if err == unix.ESRCH {
-			return -1, nil
-		}
-		return -1, fmt.Errorf("pinging QEMU process: %w", err)
-	}
-	return pid, nil
-}
diff --git a/pkg/machine/qemu/machine_windows.go b/pkg/machine/qemu/machine_windows.go
index b31a4f1d1..8c5da41cb 100644
--- a/pkg/machine/qemu/machine_windows.go
+++ b/pkg/machine/qemu/machine_windows.go
@@ -6,14 +6,29 @@ import (
 	"regexp"
 	"strings"
 
+	gvproxy "github.com/containers/gvisor-tap-vsock/pkg/types"
 	"github.com/containers/podman/v4/pkg/machine"
+	"github.com/containers/podman/v4/pkg/machine/define"
 )
 
-func isProcessAlive(pid int) bool {
+func isProcessAlive(pid int) (bool, error) {
 	if checkProcessStatus("process", pid, nil) == nil {
-		return true
+		return true, nil
 	}
-	return false
+	return false, nil
+}
+
+func pingProcess(pid int) (int, error) {
+	alive, _ := isProcessAlive(pid)
+	if !alive {
+		return -1, nil
+	}
+	return pid, nil
+}
+
+func killProcess(pid int, force bool) error {
+	machine.SendQuit(uint32(pid))
+	return nil
 }
 
 func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) error {
@@ -28,6 +43,36 @@ func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) er
 	return nil
 }
 
+func forwardPipeArgs(cmd *gvproxy.GvproxyCommand, name string, destPath string, identityPath string, user string) error {
+	machinePipe := toPipeName(name)
+	if !machine.PipeNameAvailable(machinePipe) {
+		return fmt.Errorf("could not start api proxy since expected pipe is not available: %s", machinePipe)
+	}
+	cmd.AddForwardSock(fmt.Sprintf("npipe:////./pipe/%s", machinePipe))
+	cmd.AddForwardDest(destPath)
+	cmd.AddForwardUser(user)
+	cmd.AddForwardIdentity(identityPath)
+	return nil
+}
+
+func podmanPipe(name string) *define.VMFile {
+	return &define.VMFile{Path: `\\.\pipe\` + toPipeName(name)}
+}
+
+func toPipeName(name string) string {
+	if !strings.HasPrefix(name, "qemu-podman") {
+		if !strings.HasPrefix(name, "podman") {
+			name = "podman-" + name
+		}
+		name = "qemu-" + name
+	}
+	return name
+}
+
+func useFdVLan() bool {
+	return false
+}
+
 func pathsFromVolume(volume string) []string {
 	paths := strings.SplitN(volume, ":", 3)
 	driveLetterMatcher := regexp.MustCompile(`^(?:\\\\[.?]\\)?[a-zA-Z]$`)
@@ -50,11 +95,3 @@ func extractTargetPath(paths []string) string {
 	dedup := regexp.MustCompile(`//+`)
 	return dedup.ReplaceAllLiteralString("/"+target, "/")
 }
-
-func sigKill(pid int) error {
-	return nil
-}
-
-func findProcess(pid int) (int, error) {
-	return -1, nil
-}
diff --git a/pkg/machine/qemu/qemu_command_test.go b/pkg/machine/qemu/qemu_command_test.go
index 5041dcb15..0597035b9 100644
--- a/pkg/machine/qemu/qemu_command_test.go
+++ b/pkg/machine/qemu/qemu_command_test.go
@@ -41,7 +41,8 @@ func TestQemuCmd(t *testing.T) {
 	cmd.SetCPUs(4)
 	cmd.SetIgnitionFile(*ignFile)
 	cmd.SetQmpMonitor(monitor)
-	cmd.SetNetwork()
+	err = cmd.SetNetwork("test-machine")
+	assert.NoError(t, err)
 	cmd.SetSerialPort(*readySocket, *vmPidFile, "test-machine")
 	cmd.SetVirtfsMount("/tmp/path", "vol10", "none", true)
 	cmd.SetBootableImage(bootableImagePath)
diff --git a/pkg/machine/wsl/machine.go b/pkg/machine/wsl/machine.go
index bd6b391cf..b3eb69e8a 100644
--- a/pkg/machine/wsl/machine.go
+++ b/pkg/machine/wsl/machine.go
@@ -1547,7 +1547,7 @@ func stopWinProxy(v *MachineVM) error {
 	if err != nil {
 		return nil
 	}
-	sendQuit(tid)
+	machine.SendQuit(tid)
 	_ = waitTimeout(proc, 20*time.Second)
 	_ = os.Remove(tidFile)
 
diff --git a/pkg/machine/wsl/util_windows.go b/pkg/machine/wsl/util_windows.go
index fac85f9b9..b7a7b0661 100644
--- a/pkg/machine/wsl/util_windows.go
+++ b/pkg/machine/wsl/util_windows.go
@@ -68,7 +68,6 @@ const (
 	TOKEN_QUERY                     = 0x0008
 	SE_PRIVILEGE_ENABLED            = 0x00000002
 	SE_ERR_ACCESSDENIED             = 0x05
-	WM_QUIT                         = 0x12
 )
 
 func winVersionAtLeast(major uint, minor uint, build uint) bool {
@@ -338,9 +337,3 @@ func buildCommandArgs(elevate bool) string {
 	}
 	return strings.Join(args, " ")
 }
-
-func sendQuit(tid uint32) {
-	user32 := syscall.NewLazyDLL("user32.dll")
-	postMessage := user32.NewProc("PostThreadMessageW")
-	postMessage.Call(uintptr(tid), WM_QUIT, 0, 0)
-}
-- 
2.43.0

