From e8fd434cf485b1eee2e5140f3a83a5d203b92b5f Mon Sep 17 00:00:00 2001
From: Arthur Sengileyev <arthur.sengileyev@gmail.com>
Date: Sat, 4 Feb 2023 13:19:42 +0200
Subject: [PATCH 2/3] Implement Unix domain socket support for VLAN

This change adds support for new QEMU stream netdev added in 7.2.0.
It is implemented as an opt-in mode for previously supported
platforms and the only supported mode on Windows.

Old FD netdev has changes only on podman side. Instead of previously
used QMP socket address, it now has VLAN dedicated socket address to
make both implementations more similar.

As VLAN socket address has short lifespan (it exists only after
forwarder has been started and before QEMU has finished startup),
it is not promoted to persisted machine settings, but is rather
calculated inside Start method.

Signed-off-by: Arthur Sengileyev <arthur.sengileyev@gmail.com>
---
 pkg/machine/qemu/machine.go         | 234 +++++++++++++++++++---------
 pkg/machine/qemu/machine_unix.go    |  16 +-
 pkg/machine/qemu/machine_windows.go |  30 ++++
 3 files changed, 207 insertions(+), 73 deletions(-)

diff --git a/pkg/machine/qemu/machine.go b/pkg/machine/qemu/machine.go
index baf2c5c8f..a80334d6e 100644
--- a/pkg/machine/qemu/machine.go
+++ b/pkg/machine/qemu/machine.go
@@ -55,6 +55,8 @@ const (
 	dockerSock           = "/var/run/docker.sock"
 	dockerConnectTimeout = 5 * time.Second
 	apiUpTimeout         = 20 * time.Second
+	retryCountForStart   = 6
+	retryCountForStop    = 5
 )
 
 // NewMachine initializes an instance of a virtual machine based on the qemu
@@ -123,11 +125,19 @@ func (p *Virtualization) NewMachine(opts machine.InitOptions) (machine.VM, error
 	// Add network
 	// Right now the mac address is hardcoded so that the host networking gives it a specific IP address.  This is
 	// why we can only run one vm at a time right now
-	cmd = append(cmd, []string{"-netdev", "socket,id=vlan,fd=3", "-device", "virtio-net-pci,netdev=vlan,mac=5a:94:ef:e4:0c:ee"}...)
+	if useFdVLan() {
+		cmd = append(cmd, []string{"-netdev", fdVlanNetdev()}...)
+	} else {
+		vlanSocket, err := machineSocket(vm.Name, "vlan", "")
+		if err != nil {
+			return nil, err
+		}
+		cmd = append(cmd, []string{"-netdev", socketVlanNetdev(vlanSocket.GetPath())}...)
+	}
 	if err := vm.setReadySocket(); err != nil {
 		return nil, err
 	}
-
+	cmd = append(cmd, []string{"-device", "virtio-net-pci,netdev=vlan,mac=5a:94:ef:e4:0c:ee"}...)
 	// Add serial port for readiness
 	cmd = append(cmd, []string{
 		"-device", "virtio-serial",
@@ -317,6 +327,9 @@ func (v *MachineVM) Init(opts machine.InitOptions) (bool, error) {
 	}
 	v.Mounts = mounts
 	v.UID = os.Getuid()
+	if v.UID == -1 {
+		v.UID = 501 // Used on Windows to match FCOS image
+	}
 
 	// Add location of bootable image
 	v.CmdLine = append(v.CmdLine, "-drive", "if=virtio,file="+v.getImageFile())
@@ -483,6 +496,7 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 	var (
 		conn           net.Conn
 		err            error
+		fd             *os.File
 		qemuSocketConn net.Conn
 		wait           = time.Millisecond * 500
 	)
@@ -515,11 +529,6 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 		logrus.Errorf("machine %q is incompatible with this release of podman and needs to be recreated, starting for recovery only", v.Name)
 	}
 
-	forwardSock, forwardState, err := v.startHostNetworking()
-	if err != nil {
-		return fmt.Errorf("unable to start host networking: %q", err)
-	}
-
 	rtPath, err := getRuntimeDir()
 	if err != nil {
 		return err
@@ -533,29 +542,88 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 		}
 	}
 
-	// If the qemusocketpath exists and the vm is off/down, we should rm
-	// it before the dial as to avoid a segv
-	if err := v.QMPMonitor.Address.Delete(); err != nil {
+	vlanSocket, err := machineSocket(v.Name, "vlan", "")
+	if err != nil {
 		return err
 	}
-	for i := 0; i < 6; i++ {
-		qemuSocketConn, err = net.Dial("unix", v.QMPMonitor.Address.GetPath())
-		if err == nil {
-			break
+
+	isFdVlanVM := false
+	cmdLine := v.CmdLine
+	for _, c := range v.CmdLine {
+		if c == fdVlanNetdev() {
+			isFdVlanVM = true
 		}
-		time.Sleep(wait)
-		wait++
 	}
-	if err != nil {
-		return err
+
+	cmdLine = propagateHostEnv(cmdLine)
+
+	// Show migration recommendation if machine was created with different settings
+	if isFdVlanVM != useFdVLan() {
+		if isFdVlanVM {
+			logrus.Debug("This Podman Machine is configured to use FD VLAN, but current configuration for new machines is Socket VLAN")
+			logrus.Debugf("Consider replacing %q with %q in machine config", fdVlanNetdev(), socketVlanNetdev(vlanSocket.GetPath()))
+		} else {
+			logrus.Debug("This Podman Machine is configured to use Socket VLAN, but current configuration for new machines is FD VLAN")
+			logrus.Debugf("Consider replacing %q with %q in machine config", socketVlanNetdev(vlanSocket.GetPath()), fdVlanNetdev())
+		}
+	}
+
+	// Disable graphic window when not in debug mode
+	// Done in start, so we're not suck with the debug level we used on init
+	if !logrus.IsLevelEnabled(logrus.DebugLevel) {
+		cmdLine = append(cmdLine, "-display", "none")
 	}
-	defer qemuSocketConn.Close()
 
-	fd, err := qemuSocketConn.(*net.UnixConn).File()
+	forwardSock, forwardState, forwarderProcess, err := v.startHostNetworking(vlanSocket)
 	if err != nil {
-		return err
+		return fmt.Errorf("unable to start host networking: %q", err)
+	}
+	defer func() {
+		_ = vlanSocket.Delete()
+	}()
+
+	if isFdVlanVM {
+		// If the qemusocketpath exists and the vm is off/down, we should rm
+		// it before the dial as to avoid a segv
+		if err := vlanSocket.Delete(); err != nil {
+			return err
+		}
+
+		for i := 0; i < retryCountForStart; i++ {
+			qemuSocketConn, err = net.Dial("unix", vlanSocket.GetPath())
+			if err == nil {
+				break
+			}
+			time.Sleep(wait)
+			wait++
+		}
+		if err != nil {
+			return err
+		}
+		defer qemuSocketConn.Close()
+
+		fd, err = qemuSocketConn.(*net.UnixConn).File()
+		if err != nil {
+			return err
+		}
+		defer fd.Close()
+	} else {
+		time.Sleep(wait)
+		for i := 0; i < retryCountForStart; i++ {
+			// First need to verify that gvproxy is alive,
+			// because `.sock` file could belong to a different process
+			err := checkProcessStatus(machine.ForwarderBinaryName, forwarderProcess.Pid, nil)
+			if err != nil {
+				return err
+			}
+			_, err = os.Stat(vlanSocket.GetPath())
+			if err == nil {
+				break
+			}
+			time.Sleep(wait)
+			wait++
+		}
 	}
-	defer fd.Close()
 	dnr, err := os.OpenFile(os.DevNull, os.O_RDONLY, 0755)
 	if err != nil {
 		return err
@@ -568,29 +636,25 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 	defer dnw.Close()
 
 	attr := new(os.ProcAttr)
-	files := []*os.File{dnr, dnw, dnw, fd}
-	attr.Files = files
-	cmdLine := v.CmdLine
-
-	cmdLine = propagateHostEnv(cmdLine)
-
-	// Disable graphic window when not in debug mode
-	// Done in start, so we're not suck with the debug level we used on init
-	if !logrus.IsLevelEnabled(logrus.DebugLevel) {
-		cmdLine = append(cmdLine, "-display", "none")
+	files := []*os.File{dnr, dnw, dnw}
+	if fd != nil {
+		files = append(files, fd)
 	}
+	attr.Files = files
 
 	logrus.Debugf("qemu cmd: %v", cmdLine)
 
 	stderrBuf := &bytes.Buffer{}
 
 	cmd := &exec.Cmd{
-		Args:       cmdLine,
-		Path:       cmdLine[0],
-		Stdin:      dnr,
-		Stdout:     dnw,
-		Stderr:     stderrBuf,
-		ExtraFiles: []*os.File{fd},
+		Args:   cmdLine,
+		Path:   cmdLine[0],
+		Stdin:  dnr,
+		Stdout: dnw,
+		Stderr: stderrBuf,
+	}
+	if fd != nil {
+		cmd.ExtraFiles = []*os.File{fd}
 	}
 	err = cmd.Start()
 	if err != nil {
@@ -619,16 +683,11 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 		fmt.Println("Waiting for VM ...")
 	}
 
-	socketPath, err := getRuntimeDir()
-	if err != nil {
-		return err
-	}
-
 	// The socket is not made until the qemu process is running so here
 	// we do a backoff waiting for it.  Once we have a conn, we break and
 	// then wait to read it.
-	for i := 0; i < 6; i++ {
-		conn, err = net.Dial("unix", filepath.Join(socketPath, "podman", v.Name+"_ready.sock"))
+	for i := 0; i < retryCountForStart; i++ {
+		conn, err = net.Dial("unix", v.ReadySocket.Path)
 		if err == nil {
 			break
 		}
@@ -867,7 +926,7 @@ func (v *MachineVM) Stop(_ string, _ machine.StopOptions) error {
 		// machine to stop
 		fmt.Println("Waiting for VM to stop running...")
 		waitInternal := 250 * time.Millisecond
-		for i := 0; i < 5; i++ {
+		for i := 0; i < retryCountForStop; i++ {
 			state, err := v.State(false)
 			if err != nil {
 				return err
@@ -903,32 +962,42 @@ func (v *MachineVM) Stop(_ string, _ machine.StopOptions) error {
 
 // NewQMPMonitor creates the monitor subsection of our vm
 func NewQMPMonitor(network, name string, timeout time.Duration) (Monitor, error) {
-	rtDir, err := getRuntimeDir()
+	if timeout == 0 {
+		timeout = defaultQMPTimeout
+	}
+	address, err := machineSocket(name, "qmp", "")
 	if err != nil {
 		return Monitor{}, err
 	}
+	monitor := Monitor{
+		Network: network,
+		Address: *address,
+		Timeout: timeout,
+	}
+	return monitor, nil
+}
+
+func machineSocket(name, prefix, suffix string) (*machine.VMFile, error) {
+	rtDir, err := getRuntimeDir()
+	if err != nil {
+		return nil, err
+	}
 	if isRootful() {
 		rtDir = "/run"
 	}
 	rtDir = filepath.Join(rtDir, "podman")
 	if _, err := os.Stat(rtDir); os.IsNotExist(err) {
 		if err := os.MkdirAll(rtDir, 0755); err != nil {
-			return Monitor{}, err
+			return nil, err
 		}
 	}
-	if timeout == 0 {
-		timeout = defaultQMPTimeout
+	if prefix != "" {
+		name = prefix + "_" + name
 	}
-	address, err := machine.NewMachineFile(filepath.Join(rtDir, "qmp_"+name+".sock"), nil)
-	if err != nil {
-		return Monitor{}, err
+	if suffix != "" {
+		name = name + "_" + suffix
 	}
-	monitor := Monitor{
-		Network: network,
-		Address: *address,
-		Timeout: timeout,
-	}
-	return monitor, nil
+	return machine.NewMachineFile(filepath.Join(rtDir, name+".sock"), nil)
 }
 
 // Remove deletes all the files associated with a machine including ssh keys, the image itself
@@ -1233,24 +1302,24 @@ func (p *Virtualization) Format() machine.ImageFormat {
 
 // startHostNetworking runs a binary on the host system that allows users
 // to set up port forwarding to the podman virtual machine
-func (v *MachineVM) startHostNetworking() (string, machine.APIForwardingState, error) {
+func (v *MachineVM) startHostNetworking(vlanSocket *machine.VMFile) (string, machine.APIForwardingState, *os.Process, error) {
 	cfg, err := config.Default()
 	if err != nil {
-		return "", machine.NoForwarding, err
+		return "", machine.NoForwarding, nil, err
 	}
 	binary, err := cfg.FindHelperBinary(machine.ForwarderBinaryName, false)
 	if err != nil {
-		return "", machine.NoForwarding, err
+		return "", machine.NoForwarding, nil, err
 	}
 
 	attr := new(os.ProcAttr)
 	dnr, err := os.OpenFile(os.DevNull, os.O_RDONLY, 0755)
 	if err != nil {
-		return "", machine.NoForwarding, err
+		return "", machine.NoForwarding, nil, err
 	}
 	dnw, err := os.OpenFile(os.DevNull, os.O_WRONLY, 0755)
 	if err != nil {
-		return "", machine.NoForwarding, err
+		return "", machine.NoForwarding, nil, err
 	}
 
 	defer dnr.Close()
@@ -1258,7 +1327,7 @@ func (v *MachineVM) startHostNetworking() (string, machine.APIForwardingState, e
 
 	attr.Files = []*os.File{dnr, dnw, dnw}
 	cmd := []string{binary}
-	cmd = append(cmd, []string{"-listen-qemu", fmt.Sprintf("unix://%s", v.QMPMonitor.Address.GetPath()), "-pid-file", v.PidFilePath.GetPath()}...)
+	cmd = append(cmd, []string{"-listen-qemu", fmt.Sprintf("unix://%s", strings.ReplaceAll(vlanSocket.GetPath(), "\\", "/")), "-pid-file", v.PidFilePath.GetPath()}...)
 	// Add the ssh port
 	cmd = append(cmd, []string{"-ssh-port", fmt.Sprintf("%d", v.Port)}...)
 
@@ -1272,11 +1341,11 @@ func (v *MachineVM) startHostNetworking() (string, machine.APIForwardingState, e
 		cmd = append(cmd, "--debug")
 		fmt.Println(cmd)
 	}
-	_, err = os.StartProcess(cmd[0], cmd, attr)
+	proc, err := os.StartProcess(cmd[0], cmd, attr)
 	if err != nil {
-		return "", 0, fmt.Errorf("unable to execute: %q: %w", cmd, err)
+		return "", 0, nil, fmt.Errorf("unable to execute: %q: %w", cmd, err)
 	}
-	return forwardSock, state, nil
+	return forwardSock, state, proc, nil
 }
 
 func (v *MachineVM) setupAPIForwarding(cmd []string) ([]string, string, machine.APIForwardingState) {
@@ -1294,10 +1363,10 @@ func (v *MachineVM) setupAPIForwarding(cmd []string) ([]string, string, machine.
 		forwardUser = "root"
 	}
 
-	cmd = append(cmd, []string{"-forward-sock", socket.GetPath()}...)
-	cmd = append(cmd, []string{"-forward-dest", destSock}...)
-	cmd = append(cmd, []string{"-forward-user", forwardUser}...)
-	cmd = append(cmd, []string{"-forward-identity", v.IdentityPath}...)
+	cmd, err = forwardSocketArgs(cmd, v.Name, socket.GetPath(), destSock, v.IdentityPath, forwardUser)
+	if err != nil {
+		return cmd, "", machine.NoForwarding
+	}
 
 	// The linking pattern is /var/run/docker.sock -> user global sock (link) -> machine sock (socket)
 	// This allows the helper to only have to maintain one constant target to the user, which can be
@@ -1613,6 +1682,7 @@ func (v *MachineVM) Inspect() (*machine.InspectInfo, error) {
 		return nil, err
 	}
 	connInfo.PodmanSocket = podmanSocket
+	connInfo.PodmanPipe = podmanPipe(v.Name)
 	return &machine.InspectInfo{
 		ConfigPath:         v.ConfigPath,
 		ConnectionInfo:     *connInfo,
@@ -1768,6 +1838,26 @@ func (p *Virtualization) VMType() machine.VMType {
 	return vmtype
 }
 
+func fdVlanNetdev() string {
+	return "socket,id=vlan,fd=3"
+}
+
+func socketVlanNetdev(path string) string {
+	return fmt.Sprintf("stream,id=vlan,server=off,addr.type=unix,addr.path=%s", path)
+}
+
+func forwardSocketArgs(cmd []string, name string, path string, destPath string, identityPath string, user string) ([]string, error) {
+	cmd, err := forwardPipeArgs(cmd, name, destPath, identityPath, user)
+	if err != nil {
+		return cmd, err
+	}
+	cmd = append(cmd, []string{"-forward-sock", path}...)
+	cmd = append(cmd, []string{"-forward-dest", destPath}...)
+	cmd = append(cmd, []string{"-forward-user", user}...)
+	cmd = append(cmd, []string{"-forward-identity", identityPath}...)
+	return cmd, nil
+}
+
 func isRootful() bool {
 	// Rootless is not relevant on Windows. In the future rootless.IsRootless
 	// could be switched to return true on Windows, and other codepaths migrated
diff --git a/pkg/machine/qemu/machine_unix.go b/pkg/machine/qemu/machine_unix.go
index b798d03db..9728af8e7 100644
--- a/pkg/machine/qemu/machine_unix.go
+++ b/pkg/machine/qemu/machine_unix.go
@@ -6,9 +6,11 @@ package qemu
 import (
 	"bytes"
 	"fmt"
+	"os"
 	"strings"
 	"syscall"
 
+	"github.com/containers/podman/v4/pkg/machine"
 	"golang.org/x/sys/unix"
 )
 
@@ -24,7 +26,7 @@ func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) er
 	var status syscall.WaitStatus
 	pid, err := syscall.Wait4(pid, &status, syscall.WNOHANG, nil)
 	if err != nil {
-		return fmt.Errorf("failed to read qem%su process status: %w", processHint, err)
+		return fmt.Errorf("failed to read %s process status: %w", processHint, err)
 	}
 	if pid > 0 {
 		// child exited
@@ -33,6 +35,18 @@ func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) er
 	return nil
 }
 
+func forwardPipeArgs(cmd []string, name string, destPath string, identityPath string, user string) ([]string, error) {
+	return cmd, nil
+}
+
+func podmanPipe(name string) *machine.VMFile {
+	return nil
+}
+
+func useFdVLan() bool {
+	return strings.ToUpper(os.Getenv("CONTAINERS_USE_SOCKET_VLAN")) != "TRUE"
+}
+
 func pathsFromVolume(volume string) []string {
 	return strings.SplitN(volume, ":", 3)
 }
diff --git a/pkg/machine/qemu/machine_windows.go b/pkg/machine/qemu/machine_windows.go
index 04065cb1d..986ff61f7 100644
--- a/pkg/machine/qemu/machine_windows.go
+++ b/pkg/machine/qemu/machine_windows.go
@@ -28,6 +28,36 @@ func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) er
 	return nil
 }
 
+func forwardPipeArgs(cmd []string, name string, destPath string, identityPath string, user string) ([]string, error) {
+	machinePipe := toPipeName(name)
+	if !machine.PipeNameAvailable(machinePipe) {
+		return nil, fmt.Errorf("could not start api proxy since expected pipe is not available: %s", machinePipe)
+	}
+	cmd = append(cmd, []string{"-forward-sock", fmt.Sprintf("npipe:////./pipe/%s", machinePipe)}...)
+	cmd = append(cmd, []string{"-forward-dest", destPath}...)
+	cmd = append(cmd, []string{"-forward-user", user}...)
+	cmd = append(cmd, []string{"-forward-identity", identityPath}...)
+	return cmd, nil
+}
+
+func podmanPipe(name string) *machine.VMFile {
+	return &machine.VMFile{Path: `\\.\pipe\` + toPipeName(name)}
+}
+
+func toPipeName(name string) string {
+	if !strings.HasPrefix(name, "qemu-podman") {
+		if !strings.HasPrefix(name, "podman") {
+			name = "podman-" + name
+		}
+		name = "qemu-" + name
+	}
+	return name
+}
+
+func useFdVLan() bool {
+	return false
+}
+
 func pathsFromVolume(volume string) []string {
 	paths := strings.SplitN(volume, ":", 3)
 	driveLetterMatcher := regexp.MustCompile(`^(?:\\\\[.?]\\)?[a-zA-Z]$`)
-- 
2.40.1

