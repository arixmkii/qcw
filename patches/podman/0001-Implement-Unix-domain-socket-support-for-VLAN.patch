From 5726c7fd4e5f937ef07aa117bca00aa79fc63b0a Mon Sep 17 00:00:00 2001
From: Arthur Sengileyev <arthur.sengileyev@gmail.com>
Date: Tue, 26 Sep 2023 14:52:38 +0300
Subject: [PATCH 1/2] Implement Unix domain socket support for VLAN

This change adds support for new QEMU stream netdev added in 7.2.0.
It is implemented as an opt-in mode for previously supported
platforms and the only supported mode on Windows.

Old FD netdev has changes only on podman side. Instead of previously
used QMP socket address, it now has VLAN dedicated socket address to
make both implementations more similar.

As VLAN socket address has short lifespan (it exists only after
forwarder has been started and before QEMU has finished startup),
it is not promoted to persisted machine settings, but is rather
calculated inside Start method.

Signed-off-by: Arthur Sengileyev <arthur.sengileyev@gmail.com>
---
 pkg/machine/e2e/README.md                     |  15 ++
 pkg/machine/machine_windows.go                |  11 +
 pkg/machine/qemu/command/command.go           |  24 +-
 pkg/machine/qemu/command/command_unix.go      |  13 ++
 pkg/machine/qemu/command/command_windows.go   |   5 +
 pkg/machine/qemu/command/qemu_command_test.go |   3 +-
 pkg/machine/qemu/config.go                    |  15 +-
 pkg/machine/qemu/machine.go                   | 209 ++++++++++++------
 pkg/machine/qemu/machine_unix.go              |  51 +++--
 pkg/machine/qemu/machine_windows.go           |  55 ++++-
 pkg/machine/wsl/machine.go                    |   2 +-
 pkg/machine/wsl/util_windows.go               |   7 -
 12 files changed, 300 insertions(+), 110 deletions(-)
 create mode 100644 pkg/machine/qemu/command/command_unix.go
 create mode 100644 pkg/machine/qemu/command/command_windows.go

diff --git a/pkg/machine/e2e/README.md b/pkg/machine/e2e/README.md
index 5a1e324a2..aab722355 100644
--- a/pkg/machine/e2e/README.md
+++ b/pkg/machine/e2e/README.md
@@ -36,3 +36,18 @@ Note: To run specific test files, add the test files to the end of the winmake c
 1. `export CONTAINERS_MACHINE_PROVIDER="applehv"`
 1. `export MACHINE_IMAGE="https://fedorapeople.org/groups/podman/testing/applehv/arm64/fedora-coreos-38.20230925.dev.0-applehv.aarch64.raw.gz"`
 1. `make localmachine` (Add `FOCUS_FILE=basic_test.go` to only run basic test)
+
+### QEMU (fd vlan)
+
+1. Install QEMU `brew install qemu`
+1. Install Podman (needed to have gvproxy binary) `brew install podman`
+1. `make podman-remote`
+1. `make localmachine` (Add `FOCUS_FILE=basic_test.go` to only run basic test)
+
+### QEMU (UNIX domain socket vlan)
+
+1. Install QEMU `brew install qemu`
+1. Install Podman (needed to have gvproxy binary) `brew install podman`
+1. `make podman-remote`
+1. `export CONTAINERS_USE_SOCKET_VLAN=true`
+1. `make localmachine` (Add `FOCUS_FILE=basic_test.go` to only run basic test)
diff --git a/pkg/machine/machine_windows.go b/pkg/machine/machine_windows.go
index 993aeefd4..4136368b9 100644
--- a/pkg/machine/machine_windows.go
+++ b/pkg/machine/machine_windows.go
@@ -10,6 +10,17 @@ import (
 	"github.com/sirupsen/logrus"
 )
 
+// nolint // Cleaner to refer to the official OS constant names, and consistent with syscall
+const (
+	WM_QUIT = 0x12
+)
+
+func SendQuit(tid uint32) {
+	user32 := syscall.NewLazyDLL("user32.dll")
+	postMessage := user32.NewProc("PostThreadMessageW")
+	postMessage.Call(uintptr(tid), WM_QUIT, 0, 0)
+}
+
 func GetProcessState(pid int) (active bool, exitCode int) {
 	const da = syscall.STANDARD_RIGHTS_READ | syscall.PROCESS_QUERY_INFORMATION | syscall.SYNCHRONIZE
 	handle, err := syscall.OpenProcess(da, false, uint32(pid))
diff --git a/pkg/machine/qemu/command/command.go b/pkg/machine/qemu/command/command.go
index 3619619ef..2a86bd40e 100644
--- a/pkg/machine/qemu/command/command.go
+++ b/pkg/machine/qemu/command/command.go
@@ -2,6 +2,7 @@ package command
 
 import (
 	"encoding/base64"
+	"errors"
 	"fmt"
 	"os"
 	"path/filepath"
@@ -14,6 +15,11 @@ import (
 	"github.com/containers/podman/v4/pkg/machine/define"
 )
 
+const (
+	FdVlanNetdev = "socket,id=vlan,fd=3"
+	vlanMac      = "5a:94:ef:e4:0c:ee"
+)
+
 // QemuCmd is an alias around a string slice to prevent the need to migrate the
 // MachineVM struct due to changes
 type QemuCmd []string
@@ -47,13 +53,25 @@ func (q *QemuCmd) SetQmpMonitor(monitor Monitor) {
 }
 
 // SetNetwork adds a network device to the machine
-func (q *QemuCmd) SetNetwork() {
+func (q *QemuCmd) SetNetwork(vlanSocket *define.VMFile) error {
 	// Right now the mac address is hardcoded so that the host networking gives it a specific IP address.  This is
 	// why we can only run one vm at a time right now
-	*q = append(*q, "-netdev", "socket,id=vlan,fd=3", "-device", "virtio-net-pci,netdev=vlan,mac=5a:94:ef:e4:0c:ee")
+	if UseFdVLan() {
+		*q = append(*q, []string{"-netdev", FdVlanNetdev}...)
+	} else {
+		if vlanSocket == nil {
+			return errors.New("vlanSocket is undefined")
+		}
+		*q = append(*q, []string{"-netdev", socketVlanNetdev(vlanSocket.GetPath())}...)
+	}
+	*q = append(*q, []string{"-device", "virtio-net-pci,netdev=vlan,mac=" + vlanMac}...)
+	return nil
+}
+
+func socketVlanNetdev(path string) string {
+	return fmt.Sprintf("stream,id=vlan,server=off,addr.type=unix,addr.path=%s", path)
 }
 
-// SetNetwork adds a network device to the machine
 func (q *QemuCmd) SetUSBHostPassthrough(usbs []USBConfig) {
 	if len(usbs) == 0 {
 		return
diff --git a/pkg/machine/qemu/command/command_unix.go b/pkg/machine/qemu/command/command_unix.go
new file mode 100644
index 000000000..b05e0ca51
--- /dev/null
+++ b/pkg/machine/qemu/command/command_unix.go
@@ -0,0 +1,13 @@
+//go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd
+// +build darwin dragonfly freebsd linux netbsd openbsd
+
+package command
+
+import (
+	"os"
+	"strings"
+)
+
+func UseFdVLan() bool {
+	return strings.ToUpper(os.Getenv("CONTAINERS_USE_SOCKET_VLAN")) != "TRUE"
+}
diff --git a/pkg/machine/qemu/command/command_windows.go b/pkg/machine/qemu/command/command_windows.go
new file mode 100644
index 000000000..9fdea7e3f
--- /dev/null
+++ b/pkg/machine/qemu/command/command_windows.go
@@ -0,0 +1,5 @@
+package command
+
+func UseFdVLan() bool {
+	return false
+}
diff --git a/pkg/machine/qemu/command/qemu_command_test.go b/pkg/machine/qemu/command/qemu_command_test.go
index 5cfa6c0d5..bb79b5be4 100644
--- a/pkg/machine/qemu/command/qemu_command_test.go
+++ b/pkg/machine/qemu/command/qemu_command_test.go
@@ -40,7 +40,8 @@ func TestQemuCmd(t *testing.T) {
 	cmd.SetCPUs(4)
 	cmd.SetIgnitionFile(*ignFile)
 	cmd.SetQmpMonitor(monitor)
-	cmd.SetNetwork()
+	err = cmd.SetNetwork(nil)
+	assert.NoError(t, err)
 	cmd.SetSerialPort(*readySocket, *vmPidFile, "test-machine")
 	cmd.SetVirtfsMount("/tmp/path", "vol10", "none", true)
 	cmd.SetBootableImage(bootableImagePath)
diff --git a/pkg/machine/qemu/config.go b/pkg/machine/qemu/config.go
index e15e7b038..a47232fdd 100644
--- a/pkg/machine/qemu/config.go
+++ b/pkg/machine/qemu/config.go
@@ -61,15 +61,22 @@ func (v *MachineVM) setQMPMonitorSocket() error {
 
 // setNewMachineCMD configure the CLI command that will be run to create the new
 // machine
-func (v *MachineVM) setNewMachineCMD(qemuBinary string, cmdOpts *setNewMachineCMDOpts) {
+func (v *MachineVM) setNewMachineCMD(qemuBinary string, cmdOpts *setNewMachineCMDOpts) error {
 	v.CmdLine = command.NewQemuBuilder(qemuBinary, v.addArchOptions(cmdOpts))
 	v.CmdLine.SetMemory(v.Memory)
 	v.CmdLine.SetCPUs(v.CPUs)
 	v.CmdLine.SetIgnitionFile(v.IgnitionFile)
 	v.CmdLine.SetQmpMonitor(v.QMPMonitor)
-	v.CmdLine.SetNetwork()
+	vlanSocket, err := machineSocket(v.Name, "vlan", "")
+	if err != nil {
+		return err
+	}
+	if err := v.CmdLine.SetNetwork(vlanSocket); err != nil {
+		return err
+	}
 	v.CmdLine.SetSerialPort(v.ReadySocket, v.VMPidFilePath, v.Name)
 	v.CmdLine.SetUSBHostPassthrough(v.USBs)
+	return nil
 }
 
 // NewMachine initializes an instance of a virtual machine based on the qemu
@@ -146,7 +153,9 @@ func (p *QEMUVirtualization) NewMachine(opts machine.InitOptions) (machine.VM, e
 
 	// configure command to run
 	cmdOpts := setNewMachineCMDOpts{imageDir: dataDir}
-	vm.setNewMachineCMD(execPath, &cmdOpts)
+	if err := vm.setNewMachineCMD(execPath, &cmdOpts); err != nil {
+		return nil, err
+	}
 	return vm, nil
 }
 
diff --git a/pkg/machine/qemu/machine.go b/pkg/machine/qemu/machine.go
index 14ab01d79..7db208240 100644
--- a/pkg/machine/qemu/machine.go
+++ b/pkg/machine/qemu/machine.go
@@ -45,6 +45,10 @@ const (
 	MountType9p          = "9p"
 	dockerSock           = "/var/run/docker.sock"
 	dockerConnectTimeout = 5 * time.Second
+	retryCountForStop    = 5
+	fallbackUID          = 501
+	baseBackoff          = 500 * time.Millisecond
+	maxStartupBackoffs   = 6
 )
 
 type MachineVM struct {
@@ -144,6 +148,9 @@ func (v *MachineVM) Init(opts machine.InitOptions) (bool, error) {
 	}
 
 	v.UID = os.Getuid()
+	if v.UID == -1 {
+		v.UID = fallbackUID // Used on Windows to match FCOS image
+	}
 
 	// Add location of bootable image
 	v.CmdLine.SetBootableImage(v.getImageFile())
@@ -428,20 +435,18 @@ func (v *MachineVM) qemuPid() (int, error) {
 		logrus.Warnf("Reading QEMU pidfile: %v", err)
 		return -1, nil
 	}
-	return findProcess(pid)
+
+	return pingProcess(pid)
 }
 
 // Start executes the qemu command line and forks it
 func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 	var (
-		conn           net.Conn
-		err            error
-		qemuSocketConn net.Conn
+		conn net.Conn
+		err  error
+		fd   *os.File
 	)
 
-	defaultBackoff := 500 * time.Millisecond
-	maxBackoffs := 6
-
 	v.lock.Lock()
 	defer v.lock.Unlock()
 
@@ -495,11 +500,6 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 		logrus.Errorf("machine %q is incompatible with this release of podman and needs to be recreated, starting for recovery only", v.Name)
 	}
 
-	forwardSock, forwardState, err := v.startHostNetworking()
-	if err != nil {
-		return fmt.Errorf("unable to start host networking: %q", err)
-	}
-
 	rtPath, err := getRuntimeDir()
 	if err != nil {
 		return err
@@ -513,23 +513,44 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 		}
 	}
 
-	// If the qemusocketpath exists and the vm is off/down, we should rm
-	// it before the dial as to avoid a segv
-	if err := v.QMPMonitor.Address.Delete(); err != nil {
+	vlanSocket, err := machineSocket(v.Name, "vlan", "")
+	if err != nil {
+		return fmt.Errorf("failed to connect to qemu monitor socket: %w", err)
+	}
+	err = vlanSocket.Delete()
+	if err != nil {
 		return err
 	}
+	isFdVlanVM := false
+	for _, c := range v.CmdLine {
+		if c == command.FdVlanNetdev {
+			isFdVlanVM = true
+		}
+	}
 
-	qemuSocketConn, err = sockets.DialSocketWithBackoffs(maxBackoffs, defaultBackoff, v.QMPMonitor.Address.Path)
+	forwardSock, forwardState, forwarderProcess, err := v.startHostNetworking(vlanSocket)
 	if err != nil {
-		return fmt.Errorf("failed to connect to qemu monitor socket: %w", err)
+		return fmt.Errorf("unable to start host networking: %q", err)
 	}
-	defer qemuSocketConn.Close()
 
-	fd, err := qemuSocketConn.(*net.UnixConn).File()
-	if err != nil {
-		return err
+	if isFdVlanVM {
+		qemuSocketConn, err := sockets.DialSocketWithBackoffs(maxStartupBackoffs, baseBackoff, vlanSocket.GetPath())
+		if err != nil {
+			return err
+		}
+		defer qemuSocketConn.Close()
+
+		fd, err = qemuSocketConn.(*net.UnixConn).File()
+		if err != nil {
+			return err
+		}
+		defer fd.Close()
+	} else {
+		err := waitForVlanReady(forwarderProcess.Pid, vlanSocket.GetPath())
+		if err != nil {
+			return err
+		}
 	}
-	defer fd.Close()
 
 	dnr, dnw, err := machine.GetDevNullFiles()
 	if err != nil {
@@ -538,9 +559,6 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 	defer dnr.Close()
 	defer dnw.Close()
 
-	attr := new(os.ProcAttr)
-	files := []*os.File{dnr, dnw, dnw, fd}
-	attr.Files = files
 	cmdLine := v.CmdLine
 
 	cmdLine.SetPropagatedHostEnvs()
@@ -557,12 +575,15 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 
 	// actually run the command that starts the virtual machine
 	cmd := &exec.Cmd{
-		Args:       cmdLine,
-		Path:       cmdLine[0],
-		Stdin:      dnr,
-		Stdout:     dnw,
-		Stderr:     stderrBuf,
-		ExtraFiles: []*os.File{fd},
+		Args:   cmdLine,
+		Path:   cmdLine[0],
+		Stdin:  dnr,
+		Stdout: dnw,
+		Stderr: stderrBuf,
+	}
+	// Forward FD if one was allocated
+	if fd != nil {
+		cmd.ExtraFiles = []*os.File{fd}
 	}
 
 	if err := runStartVMCommand(cmd); err != nil {
@@ -575,7 +596,7 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 		fmt.Println("Waiting for VM ...")
 	}
 
-	conn, err = sockets.DialSocketWithBackoffsAndProcCheck(maxBackoffs, defaultBackoff, v.ReadySocket.GetPath(), checkProcessStatus, "qemu", cmd.Process.Pid, stderrBuf)
+	conn, err = sockets.DialSocketWithBackoffsAndProcCheck(maxStartupBackoffs, baseBackoff, v.ReadySocket.GetPath(), checkProcessStatus, "qemu", cmd.Process.Pid, stderrBuf)
 	if err != nil {
 		return err
 	}
@@ -609,7 +630,7 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 		return nil
 	}
 
-	connected, sshError, err := v.conductVMReadinessCheck(name, maxBackoffs, defaultBackoff)
+	connected, sshError, err := v.conductVMReadinessCheck(name, maxStartupBackoffs, baseBackoff)
 	if err != nil {
 		return err
 	}
@@ -639,6 +660,28 @@ func (v *MachineVM) Start(name string, opts machine.StartOptions) error {
 	return nil
 }
 
+func waitForVlanReady(pid int, vlanPath string) error {
+	time.Sleep(baseBackoff)
+	backoff := baseBackoff
+	for i := 0; i < maxStartupBackoffs; i++ {
+		if i > 0 {
+			time.Sleep(backoff)
+			backoff *= 2
+		}
+		// First need to verify that gvproxy is alive,
+		// because `.sock` file could belong to a different process
+		err := checkProcessStatus(machine.ForwarderBinaryName, pid, nil)
+		if err != nil {
+			return err
+		}
+		_, err = os.Stat(vlanPath)
+		if err == nil {
+			break
+		}
+	}
+	return nil
+}
+
 func (v *MachineVM) checkStatus(monitor *qmp.SocketMonitor) (define.Status, error) {
 	// this is the format returned from the monitor
 	// {"return": {"status": "running", "singlestep": false, "running": true}}
@@ -683,7 +726,7 @@ func (v *MachineVM) checkStatus(monitor *qmp.SocketMonitor) (define.Status, erro
 func (v *MachineVM) waitForMachineToStop() error {
 	fmt.Println("Waiting for VM to stop running...")
 	waitInternal := 250 * time.Millisecond
-	for i := 0; i < 5; i++ {
+	for i := 0; i < retryCountForStop; i++ {
 		state, err := v.State(false)
 		if err != nil {
 			return err
@@ -716,15 +759,14 @@ func (v *MachineVM) ProxyPID() (int, error) {
 	return proxyPid, nil
 }
 
-// cleanupVMProxyProcess kills the proxy process and removes the VM's pidfile
-func (v *MachineVM) cleanupVMProxyProcess(proxyProc *os.Process) error {
+// cleanupVMProxyProcess kills the proxy process
+func (v *MachineVM) cleanupVMProxyProcess(proxyPid int) error {
 	// Kill the process
-	if err := proxyProc.Kill(); err != nil {
+	if err := killProcess(proxyPid, false); err != nil {
 		return err
 	}
-	// Remove the pidfile
 	if err := v.PidFilePath.Delete(); err != nil {
-		return err
+		logrus.Debugf("Error while removing proxy pidfile: %v", err)
 	}
 	return nil
 }
@@ -768,7 +810,7 @@ func (v *MachineVM) Stop(_ string, _ machine.StopOptions) error {
 		return stopErr
 	}
 
-	if err := sigKill(qemuPid); err != nil {
+	if err := killProcess(qemuPid, true); err != nil {
 		if stopErr == nil {
 			return err
 		}
@@ -843,7 +885,7 @@ func (v *MachineVM) stopLocked() error {
 		return err
 	}
 
-	if err := v.cleanupVMProxyProcess(proxyProc); err != nil {
+	if err := v.cleanupVMProxyProcess(proxyPid); err != nil {
 		return err
 	}
 
@@ -875,8 +917,18 @@ func (v *MachineVM) stopLocked() error {
 	}
 
 	fmt.Println("Waiting for VM to exit...")
-	for isProcessAlive(vmPid) {
-		time.Sleep(500 * time.Millisecond)
+	retries := 60
+	for {
+		alive, _ := isProcessAlive(vmPid)
+		if retries <= 0 {
+			logrus.Warning("Giving up on waiting for VM to exit. VM process might still terminate")
+			break
+		}
+		if !alive {
+			break
+		}
+		time.Sleep(baseBackoff)
+		retries--
 	}
 
 	return nil
@@ -884,32 +936,42 @@ func (v *MachineVM) stopLocked() error {
 
 // NewQMPMonitor creates the monitor subsection of our vm
 func NewQMPMonitor(network, name string, timeout time.Duration) (command.Monitor, error) {
-	rtDir, err := getRuntimeDir()
+	if timeout == 0 {
+		timeout = defaultQMPTimeout
+	}
+	address, err := machineSocket(name, "qmp", "")
 	if err != nil {
 		return command.Monitor{}, err
 	}
+	monitor := command.Monitor{
+		Network: network,
+		Address: *address,
+		Timeout: timeout,
+	}
+	return monitor, nil
+}
+
+func machineSocket(name, prefix, suffix string) (*define.VMFile, error) {
+	rtDir, err := getRuntimeDir()
+	if err != nil {
+		return nil, err
+	}
 	if isRootful() {
 		rtDir = "/run"
 	}
 	rtDir = filepath.Join(rtDir, "podman")
 	if _, err := os.Stat(rtDir); errors.Is(err, fs.ErrNotExist) {
 		if err := os.MkdirAll(rtDir, 0755); err != nil {
-			return command.Monitor{}, err
+			return nil, err
 		}
 	}
-	if timeout == 0 {
-		timeout = defaultQMPTimeout
+	if prefix != "" {
+		name = prefix + "_" + name
 	}
-	address, err := define.NewMachineFile(filepath.Join(rtDir, "qmp_"+name+".sock"), nil)
-	if err != nil {
-		return command.Monitor{}, err
-	}
-	monitor := command.Monitor{
-		Network: network,
-		Address: *address,
-		Timeout: timeout,
+	if suffix != "" {
+		name = name + "_" + suffix
 	}
-	return monitor, nil
+	return define.NewMachineFile(filepath.Join(rtDir, name+".sock"), nil)
 }
 
 // collectFilesToDestroy retrieves the files that will be destroyed by `Remove`
@@ -1107,18 +1169,18 @@ func getDiskSize(path string) (uint64, error) {
 
 // startHostNetworking runs a binary on the host system that allows users
 // to set up port forwarding to the podman virtual machine
-func (v *MachineVM) startHostNetworking() (string, machine.APIForwardingState, error) {
+func (v *MachineVM) startHostNetworking(vlanSocket *define.VMFile) (string, machine.APIForwardingState, *os.Process, error) {
 	cfg, err := config.Default()
 	if err != nil {
-		return "", machine.NoForwarding, err
+		return "", machine.NoForwarding, nil, err
 	}
 	binary, err := cfg.FindHelperBinary(machine.ForwarderBinaryName, false)
 	if err != nil {
-		return "", machine.NoForwarding, err
+		return "", machine.NoForwarding, nil, err
 	}
 
 	cmd := gvproxy.NewGvproxyCommand()
-	cmd.AddQemuSocket(fmt.Sprintf("unix://%s", v.QMPMonitor.Address.GetPath()))
+	cmd.AddQemuSocket(fmt.Sprintf("unix://%s", filepath.ToSlash(vlanSocket.GetPath())))
 	cmd.PidFile = v.PidFilePath.GetPath()
 	cmd.SSHPort = v.Port
 
@@ -1133,11 +1195,13 @@ func (v *MachineVM) startHostNetworking() (string, machine.APIForwardingState, e
 		logrus.Debug(cmd)
 	}
 
+	cargs := cmd.ToCmdline()
+	logrus.Debugf("gvproxy cmd: %v", append([]string{binary}, cargs...))
 	c := cmd.Cmd(binary)
 	if err := c.Start(); err != nil {
-		return "", 0, fmt.Errorf("unable to execute: %q: %w", cmd.ToCmdline(), err)
+		return "", 0, nil, fmt.Errorf("unable to execute: %q: %w", cmd.ToCmdline(), err)
 	}
-	return forwardSock, state, nil
+	return forwardSock, state, c.Process, nil
 }
 
 func (v *MachineVM) setupAPIForwarding(cmd gvproxy.GvproxyCommand) (gvproxy.GvproxyCommand, string, machine.APIForwardingState) {
@@ -1155,10 +1219,10 @@ func (v *MachineVM) setupAPIForwarding(cmd gvproxy.GvproxyCommand) (gvproxy.Gvpr
 		forwardUser = "root"
 	}
 
-	cmd.AddForwardSock(socket.GetPath())
-	cmd.AddForwardDest(destSock)
-	cmd.AddForwardUser(forwardUser)
-	cmd.AddForwardIdentity(v.IdentityPath)
+	err = forwardSocketArgs(&cmd, v.Name, socket.GetPath(), destSock, v.IdentityPath, forwardUser)
+	if err != nil {
+		return cmd, "", machine.NoForwarding
+	}
 
 	// The linking pattern is /var/run/docker.sock -> user global sock (link) -> machine sock (socket)
 	// This allows the helper to only have to maintain one constant target to the user, which can be
@@ -1331,6 +1395,7 @@ func (v *MachineVM) Inspect() (*machine.InspectInfo, error) {
 		return nil, err
 	}
 	connInfo.PodmanSocket = podmanSocket
+	connInfo.PodmanPipe = podmanPipe(v.Name)
 	return &machine.InspectInfo{
 		ConfigPath:         v.ConfigPath,
 		ConnectionInfo:     *connInfo,
@@ -1397,6 +1462,18 @@ func (v *MachineVM) editCmdLine(flag string, value string) {
 	}
 }
 
+func forwardSocketArgs(cmd *gvproxy.GvproxyCommand, name string, path string, destPath string, identityPath string, user string) error {
+	err := forwardPipeArgs(cmd, name, destPath, identityPath, user)
+	if err != nil {
+		return err
+	}
+	cmd.AddForwardSock(path)
+	cmd.AddForwardDest(destPath)
+	cmd.AddForwardUser(user)
+	cmd.AddForwardIdentity(identityPath)
+	return nil
+}
+
 func isRootful() bool {
 	// Rootless is not relevant on Windows. In the future rootless.IsRootless
 	// could be switched to return true on Windows, and other codepaths migrated
diff --git a/pkg/machine/qemu/machine_unix.go b/pkg/machine/qemu/machine_unix.go
index 37ed1f619..a684e8a31 100644
--- a/pkg/machine/qemu/machine_unix.go
+++ b/pkg/machine/qemu/machine_unix.go
@@ -8,22 +8,43 @@ import (
 	"strings"
 	"syscall"
 
+	gvproxy "github.com/containers/gvisor-tap-vsock/pkg/types"
+	"github.com/containers/podman/v4/pkg/machine/define"
 	"golang.org/x/sys/unix"
 )
 
-func isProcessAlive(pid int) bool {
+func isProcessAlive(pid int) (bool, error) {
 	err := unix.Kill(pid, syscall.Signal(0))
 	if err == nil || err == unix.EPERM {
-		return true
+		return true, nil
+	}
+	return false, err
+}
+
+func pingProcess(pid int) (int, error) {
+	alive, err := isProcessAlive(pid)
+	if !alive {
+		if err == unix.ESRCH {
+			return -1, nil
+		}
+		return -1, fmt.Errorf("pinging QEMU process: %w", err)
+	}
+	return pid, nil
+}
+
+func killProcess(pid int, force bool) error {
+	if force {
+		return unix.Kill(pid, unix.SIGKILL)
+	} else {
+		return unix.Kill(pid, unix.SIGTERM)
 	}
-	return false
 }
 
 func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) error {
 	var status syscall.WaitStatus
 	pid, err := syscall.Wait4(pid, &status, syscall.WNOHANG, nil)
 	if err != nil {
-		return fmt.Errorf("failed to read qem%su process status: %w", processHint, err)
+		return fmt.Errorf("failed to read %s process status: %w", processHint, err)
 	}
 	if pid > 0 {
 		// child exited
@@ -32,6 +53,14 @@ func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) er
 	return nil
 }
 
+func forwardPipeArgs(cmd *gvproxy.GvproxyCommand, name string, destPath string, identityPath string, user string) error {
+	return nil
+}
+
+func podmanPipe(name string) *define.VMFile {
+	return nil
+}
+
 func pathsFromVolume(volume string) []string {
 	return strings.SplitN(volume, ":", 3)
 }
@@ -42,17 +71,3 @@ func extractTargetPath(paths []string) string {
 	}
 	return paths[0]
 }
-
-func sigKill(pid int) error {
-	return unix.Kill(pid, unix.SIGKILL)
-}
-
-func findProcess(pid int) (int, error) {
-	if err := unix.Kill(pid, 0); err != nil {
-		if err == unix.ESRCH {
-			return -1, nil
-		}
-		return -1, fmt.Errorf("pinging QEMU process: %w", err)
-	}
-	return pid, nil
-}
diff --git a/pkg/machine/qemu/machine_windows.go b/pkg/machine/qemu/machine_windows.go
index b31a4f1d1..2af13cb81 100644
--- a/pkg/machine/qemu/machine_windows.go
+++ b/pkg/machine/qemu/machine_windows.go
@@ -6,14 +6,29 @@ import (
 	"regexp"
 	"strings"
 
+	gvproxy "github.com/containers/gvisor-tap-vsock/pkg/types"
 	"github.com/containers/podman/v4/pkg/machine"
+	"github.com/containers/podman/v4/pkg/machine/define"
 )
 
-func isProcessAlive(pid int) bool {
+func isProcessAlive(pid int) (bool, error) {
 	if checkProcessStatus("process", pid, nil) == nil {
-		return true
+		return true, nil
 	}
-	return false
+	return false, nil
+}
+
+func pingProcess(pid int) (int, error) {
+	alive, _ := isProcessAlive(pid)
+	if !alive {
+		return -1, nil
+	}
+	return pid, nil
+}
+
+func killProcess(pid int, force bool) error {
+	machine.SendQuit(uint32(pid))
+	return nil
 }
 
 func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) error {
@@ -28,6 +43,32 @@ func checkProcessStatus(processHint string, pid int, stderrBuf *bytes.Buffer) er
 	return nil
 }
 
+func forwardPipeArgs(cmd *gvproxy.GvproxyCommand, name string, destPath string, identityPath string, user string) error {
+	machinePipe := toPipeName(name)
+	if !machine.PipeNameAvailable(machinePipe) {
+		return fmt.Errorf("could not start api proxy since expected pipe is not available: %s", machinePipe)
+	}
+	cmd.AddForwardSock(fmt.Sprintf("npipe:////./pipe/%s", machinePipe))
+	cmd.AddForwardDest(destPath)
+	cmd.AddForwardUser(user)
+	cmd.AddForwardIdentity(identityPath)
+	return nil
+}
+
+func podmanPipe(name string) *define.VMFile {
+	return &define.VMFile{Path: `\\.\pipe\` + toPipeName(name)}
+}
+
+func toPipeName(name string) string {
+	if !strings.HasPrefix(name, "qemu-podman") {
+		if !strings.HasPrefix(name, "podman") {
+			name = "podman-" + name
+		}
+		name = "qemu-" + name
+	}
+	return name
+}
+
 func pathsFromVolume(volume string) []string {
 	paths := strings.SplitN(volume, ":", 3)
 	driveLetterMatcher := regexp.MustCompile(`^(?:\\\\[.?]\\)?[a-zA-Z]$`)
@@ -50,11 +91,3 @@ func extractTargetPath(paths []string) string {
 	dedup := regexp.MustCompile(`//+`)
 	return dedup.ReplaceAllLiteralString("/"+target, "/")
 }
-
-func sigKill(pid int) error {
-	return nil
-}
-
-func findProcess(pid int) (int, error) {
-	return -1, nil
-}
diff --git a/pkg/machine/wsl/machine.go b/pkg/machine/wsl/machine.go
index ee0301070..235412f4b 100644
--- a/pkg/machine/wsl/machine.go
+++ b/pkg/machine/wsl/machine.go
@@ -1537,7 +1537,7 @@ func stopWinProxy(v *MachineVM) error {
 	if err != nil {
 		return nil
 	}
-	sendQuit(tid)
+	machine.SendQuit(tid)
 	_ = waitTimeout(proc, 20*time.Second)
 	_ = os.Remove(tidFile)
 
diff --git a/pkg/machine/wsl/util_windows.go b/pkg/machine/wsl/util_windows.go
index 75a943cff..3046dca85 100644
--- a/pkg/machine/wsl/util_windows.go
+++ b/pkg/machine/wsl/util_windows.go
@@ -67,7 +67,6 @@ const (
 	TOKEN_QUERY                     = 0x0008
 	SE_PRIVILEGE_ENABLED            = 0x00000002
 	SE_ERR_ACCESSDENIED             = 0x05
-	WM_QUIT                         = 0x12
 )
 
 func winVersionAtLeast(major uint, minor uint, build uint) bool {
@@ -337,9 +336,3 @@ func buildCommandArgs(elevate bool) string {
 	}
 	return strings.Join(args, " ")
 }
-
-func sendQuit(tid uint32) {
-	user32 := syscall.NewLazyDLL("user32.dll")
-	postMessage := user32.NewProc("PostThreadMessageW")
-	postMessage.Call(uintptr(tid), WM_QUIT, 0, 0)
-}
-- 
2.43.0

