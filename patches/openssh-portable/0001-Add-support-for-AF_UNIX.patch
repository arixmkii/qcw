From 3a77587ed077d4a6f993d933960b2467e280e096 Mon Sep 17 00:00:00 2001
From: Martin Fernandez <mfernandez@crunchloop.io>
Date: Thu, 13 Apr 2023 00:19:18 +0800
Subject: [PATCH 1/9] Add support for AF_UNIX

---
 contrib/win32/win32compat/socketio.c | 10 ++++++++--
 contrib/win32/win32compat/w32fd.c    | 16 +++++-----------
 session.c                            | 14 +++++++++++++-
 3 files changed, 26 insertions(+), 14 deletions(-)

diff --git a/contrib/win32/win32compat/socketio.c b/contrib/win32/win32compat/socketio.c
index c4eceaea8..980e9d6ee 100644
--- a/contrib/win32/win32compat/socketio.c
+++ b/contrib/win32/win32compat/socketio.c
@@ -29,6 +29,7 @@
 */
 
 #include <winsock2.h>
+#include <afunix.h>
 #include <ws2tcpip.h>
 #include <mswsock.h>
 #include <errno.h>
@@ -118,7 +119,7 @@ socketio_acceptEx(struct w32_io* pio)
 	}
 
 	/* create accepting socket */
-	context->accept_socket = socket(addr.ss_family, SOCK_STREAM, IPPROTO_TCP);
+	context->accept_socket = socket(addr.ss_family, SOCK_STREAM, IPPROTO_IP);
 	if (context->accept_socket == INVALID_SOCKET) {
 		errno = errno_from_WSALastError();
 		debug3("acceptEx - socket() ERROR:%d, io:%p", WSAGetLastError(), pio);
@@ -756,7 +757,7 @@ on_error:
 int
 socketio_connectex(struct w32_io* pio, const struct sockaddr* name, int namelen)
 {
-
+	struct sockaddr_un tmp_unix;
 	struct sockaddr_in tmp_addr4;
 	struct sockaddr_in6 tmp_addr6;
 	SOCKADDR* tmp_addr;
@@ -778,6 +779,11 @@ socketio_connectex(struct w32_io* pio, const struct sockaddr* name, int namelen)
 		tmp_addr4.sin_port = 0;
 		tmp_addr = (SOCKADDR*)&tmp_addr4;
 		tmp_addr_len = sizeof(tmp_addr4);
+	} else if (name->sa_family == AF_UNIX) {
+		ZeroMemory(&tmp_unix, sizeof(tmp_unix));
+		tmp_unix.sun_family = AF_UNIX;
+		tmp_addr = (SOCKADDR*)&tmp_unix;
+		tmp_addr_len = sizeof(tmp_unix);
 	} else {
 		errno = ENOTSUP;
 		debug3("connectex - ERROR: unsuppored address family:%d, io:%p", name->sa_family, pio);
diff --git a/contrib/win32/win32compat/w32fd.c b/contrib/win32/win32compat/w32fd.c
index ed9309d54..7c57c7f0d 100644
--- a/contrib/win32/win32compat/w32fd.c
+++ b/contrib/win32/win32compat/w32fd.c
@@ -299,17 +299,11 @@ w32_socket(int domain, int type, int protocol)
 	if (min_index == -1)
 		return -1;
 	
-	if (domain == AF_UNIX && type == SOCK_STREAM) {
-		pio = fileio_afunix_socket();		
-		if (pio == NULL)
-			return -1;
-		pio->type = NONSOCK_FD;
-	} else {
-		pio = socketio_socket(domain, type, protocol);
-		if (pio == NULL)
-			return -1;
-		pio->type = SOCK_FD;
-	}	
+	pio = socketio_socket(domain, type, protocol);
+	if (pio == NULL)
+		return -1;
+	pio->type = SOCK_FD;
+
 
 	fd_table_set(pio, min_index);
 	debug4("socket:%d, socktype:%d, io:%p, fd:%d ", pio->sock, type, pio, min_index);
diff --git a/session.c b/session.c
index cb613dbb4..d148458c9 100644
--- a/session.c
+++ b/session.c
@@ -198,8 +198,15 @@ auth_input_request_forwarding(struct ssh *ssh, struct passwd * pw)
 	/* Temporarily drop privileged uid for mkdir/bind. */
 	temporarily_use_uid(pw);
 
+#ifdef WINDOWS
+	/* Allocate a buffer for the socket name, and format the name. */
+	auth_sock_dir = xstrdup("C:\\tmp\\ssh-XXXXXXXXXX");
+
+#else
 	/* Allocate a buffer for the socket name, and format the name. */
 	auth_sock_dir = xstrdup("/tmp/ssh-XXXXXXXXXX");
+#endif
+
 
 	/* Create private directory for socket */
 	if (mkdtemp(auth_sock_dir) == NULL) {
@@ -211,8 +218,13 @@ auth_input_request_forwarding(struct ssh *ssh, struct passwd * pw)
 		goto authsock_err;
 	}
 
+#ifdef WINDOWS
+	xasprintf(&auth_sock_name, "%s\\agent.%ld",
+		auth_sock_dir, (long)getpid());
+#else
 	xasprintf(&auth_sock_name, "%s/agent.%ld",
-	    auth_sock_dir, (long) getpid());
+		auth_sock_dir, (long)getpid());
+#endif
 
 	/* Start a Unix listener on auth_sock_name. */
 	sock = unix_listener(auth_sock_name, SSH_LISTEN_BACKLOG, 0);
-- 
2.43.0

From f7a8825765cfe5fc5b44d63d16751076f78d2bd9 Mon Sep 17 00:00:00 2001
From: Martin Fernandez <mfernandez@crunchloop.io>
Date: Thu, 13 Apr 2023 22:47:49 +0800
Subject: [PATCH 2/9] Guard AF_UNIX paths with HAVE_AFUNIX_H

---
 contrib/win32/openssh/config.h.vs    |  3 +++
 contrib/win32/win32compat/socketio.c | 12 ++++++++++++
 contrib/win32/win32compat/w32fd.c    | 17 +++++++++++++++--
 3 files changed, 30 insertions(+), 2 deletions(-)

diff --git a/contrib/win32/openssh/config.h.vs b/contrib/win32/openssh/config.h.vs
index d19b10758..e6b13a102 100644
--- a/contrib/win32/openssh/config.h.vs
+++ b/contrib/win32/openssh/config.h.vs
@@ -1526,6 +1526,9 @@
 /* Use PIPES instead of a socketpair() */
 #define USE_PIPES 1
 
+/* define 1 if afunix.h is available */
+#define HAVE_AFUNIX_H 1
+
 /* Define if you want to sanitize fds */
 /* #undef USE_SANITISE_STDFD */
 
diff --git a/contrib/win32/win32compat/socketio.c b/contrib/win32/win32compat/socketio.c
index 980e9d6ee..589ff5d8a 100644
--- a/contrib/win32/win32compat/socketio.c
+++ b/contrib/win32/win32compat/socketio.c
@@ -29,7 +29,9 @@
 */
 
 #include <winsock2.h>
+#ifdef HAVE_AFUNIX_H
 #include <afunix.h>
+#endif
 #include <ws2tcpip.h>
 #include <mswsock.h>
 #include <errno.h>
@@ -119,7 +121,12 @@ socketio_acceptEx(struct w32_io* pio)
 	}
 
 	/* create accepting socket */
+	#ifdef HAVE_AFUNIX_H
 	context->accept_socket = socket(addr.ss_family, SOCK_STREAM, IPPROTO_IP);
+	#else
+	context->accept_socket = socket(addr.ss_family, SOCK_STREAM, IPPROTO_TCP);
+	#endif
+
 	if (context->accept_socket == INVALID_SOCKET) {
 		errno = errno_from_WSALastError();
 		debug3("acceptEx - socket() ERROR:%d, io:%p", WSAGetLastError(), pio);
@@ -757,7 +764,10 @@ on_error:
 int
 socketio_connectex(struct w32_io* pio, const struct sockaddr* name, int namelen)
 {
+	#ifdef HAVE_AFUNIX_H
 	struct sockaddr_un tmp_unix;
+	#endif
+
 	struct sockaddr_in tmp_addr4;
 	struct sockaddr_in6 tmp_addr6;
 	SOCKADDR* tmp_addr;
@@ -779,11 +789,13 @@ socketio_connectex(struct w32_io* pio, const struct sockaddr* name, int namelen)
 		tmp_addr4.sin_port = 0;
 		tmp_addr = (SOCKADDR*)&tmp_addr4;
 		tmp_addr_len = sizeof(tmp_addr4);
+	#ifdef HAVE_AFUNIX_H
 	} else if (name->sa_family == AF_UNIX) {
 		ZeroMemory(&tmp_unix, sizeof(tmp_unix));
 		tmp_unix.sun_family = AF_UNIX;
 		tmp_addr = (SOCKADDR*)&tmp_unix;
 		tmp_addr_len = sizeof(tmp_unix);
+	#endif
 	} else {
 		errno = ENOTSUP;
 		debug3("connectex - ERROR: unsuppored address family:%d, io:%p", name->sa_family, pio);
diff --git a/contrib/win32/win32compat/w32fd.c b/contrib/win32/win32compat/w32fd.c
index 7c57c7f0d..ebcfeb8e7 100644
--- a/contrib/win32/win32compat/w32fd.c
+++ b/contrib/win32/win32compat/w32fd.c
@@ -298,12 +298,25 @@ w32_socket(int domain, int type, int protocol)
 	errno = 0;
 	if (min_index == -1)
 		return -1;
-	
+
+	#ifdef HAVE_AFUNIX_H
 	pio = socketio_socket(domain, type, protocol);
 	if (pio == NULL)
 		return -1;
 	pio->type = SOCK_FD;
-
+	#else
+	if (domain == AF_UNIX && type == SOCK_STREAM) {
+		pio = fileio_afunix_socket();
+		if (pio == NULL)
+			return -1;
+		pio->type = NONSOCK_FD;
+	} else {
+		pio = socketio_socket(domain, type, protocol);
+		if (pio == NULL)
+			return -1;
+		pio->type = SOCK_FD;
+	}
+	#endif
 
 	fd_table_set(pio, min_index);
 	debug4("socket:%d, socktype:%d, io:%p, fd:%d ", pio->sock, type, pio, min_index);
-- 
2.43.0

From 6dd4311e2102c65eb0d4d0fe8cc0df3a2a50fbbd Mon Sep 17 00:00:00 2001
From: Martin Fernandez <mfernandez@crunchloop.io>
Date: Fri, 14 Apr 2023 04:49:35 +0800
Subject: [PATCH 3/9] Use Windows GetTempPath instead of /tmp

---
 contrib/win32/win32compat/socketio.c |  7 ++++---
 contrib/win32/win32compat/w32fd.c    |  1 +
 session.c                            | 17 ++++++++++++++---
 3 files changed, 19 insertions(+), 6 deletions(-)

diff --git a/contrib/win32/win32compat/socketio.c b/contrib/win32/win32compat/socketio.c
index 589ff5d8a..d85f28ff6 100644
--- a/contrib/win32/win32compat/socketio.c
+++ b/contrib/win32/win32compat/socketio.c
@@ -29,9 +29,6 @@
 */
 
 #include <winsock2.h>
-#ifdef HAVE_AFUNIX_H
-#include <afunix.h>
-#endif
 #include <ws2tcpip.h>
 #include <mswsock.h>
 #include <errno.h>
@@ -41,6 +38,10 @@
 #include "inc\utf.h"
 #include "misc_internal.h"
 #include "debug.h"
+#include "../../../config.h"
+#ifdef HAVE_AFUNIX_H
+#include <afunix.h>
+#endif
 
 #define INTERNAL_SEND_BUFFER_SIZE 70*1024 //70KB
 #define INTERNAL_RECV_BUFFER_SIZE 70*1024 //70KB
diff --git a/contrib/win32/win32compat/w32fd.c b/contrib/win32/win32compat/w32fd.c
index ebcfeb8e7..d3c6fbe26 100644
--- a/contrib/win32/win32compat/w32fd.c
+++ b/contrib/win32/win32compat/w32fd.c
@@ -52,6 +52,7 @@
 #include <sys\utime.h>
 #include "misc_internal.h"
 #include "debug.h"
+#include "../../../config.h"
 
 /* internal table that stores the fd to w32_io mapping*/
 struct w32fd_table {
diff --git a/session.c b/session.c
index d148458c9..e8972fd4b 100644
--- a/session.c
+++ b/session.c
@@ -199,15 +199,26 @@ auth_input_request_forwarding(struct ssh *ssh, struct passwd * pw)
 	temporarily_use_uid(pw);
 
 #ifdef WINDOWS
-	/* Allocate a buffer for the socket name, and format the name. */
-	auth_sock_dir = xstrdup("C:\\tmp\\ssh-XXXXXXXXXX");
+	/* Use Windows temporal directory instead of unix `/tmp` folder */
+	static char tmp_file_path[MAX_PATH];
+	DWORD tmp_path_len = GetTempPath(MAX_PATH, tmp_file_path);
+	if (tmp_path_len > MAX_PATH || tmp_file_path == 0) {
+		error("Agent forwarding disabled: GetTempPath() failed.");
+		return 0;
+	}
 
+	char* ssh_prefix = xstrdup("ssh-XXXXXXXXXX");
+	size_t sock_dir_len = tmp_path_len + strlen(ssh_prefix) + 1;
+
+	auth_sock_dir = xmalloc(sock_dir_len);
+	memset(auth_sock_dir, 0, sock_dir_len);
+	strcat(auth_sock_dir, tmp_file_path);
+	strcat(auth_sock_dir, ssh_prefix);
 #else
 	/* Allocate a buffer for the socket name, and format the name. */
 	auth_sock_dir = xstrdup("/tmp/ssh-XXXXXXXXXX");
 #endif
 
-
 	/* Create private directory for socket */
 	if (mkdtemp(auth_sock_dir) == NULL) {
 		ssh_packet_send_debug(ssh, "Agent forwarding disabled: "
-- 
2.43.0

From b31d18151eb5368feabfde408bcdf5d732a6bc2e Mon Sep 17 00:00:00 2001
From: Martin Fernandez <mfernandez@crunchloop.io>
Date: Sat, 15 Apr 2023 03:23:47 +0800
Subject: [PATCH 4/9] Conditionally use af_unix and fileio

---
 authfd.c                                    |  8 ++-
 contrib/win32/openssh/config.h.vs           |  3 +
 contrib/win32/win32compat/ssh-agent/agent.c |  2 -
 contrib/win32/win32compat/w32fd.c           | 64 +++++++++++++++++++--
 contrib/win32/win32compat/w32fd.h           |  1 +
 misc.c                                      |  4 ++
 mux.c                                       |  8 ++-
 7 files changed, 80 insertions(+), 10 deletions(-)

diff --git a/authfd.c b/authfd.c
index b633e35ea..fafe77742 100644
--- a/authfd.c
+++ b/authfd.c
@@ -97,7 +97,13 @@ ssh_get_authentication_socket_path(const char *authsocket, int *fdp)
 	sunaddr.sun_family = AF_UNIX;
 	strlcpy(sunaddr.sun_path, authsocket, sizeof(sunaddr.sun_path));
 
-	if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
+	#ifdef HAVE_AFUNIX_H
+	sock = w32_afunix_socket(&sunaddr);
+	#else
+	sock = socket(AF_UNIX, SOCK_STREAM, 0);
+	#endif
+
+	if (sock == -1)
 		return SSH_ERR_SYSTEM_ERROR;
 
 	/* close on exec */
diff --git a/contrib/win32/openssh/config.h.vs b/contrib/win32/openssh/config.h.vs
index e6b13a102..d945e202f 100644
--- a/contrib/win32/openssh/config.h.vs
+++ b/contrib/win32/openssh/config.h.vs
@@ -1526,6 +1526,9 @@
 /* Use PIPES instead of a socketpair() */
 #define USE_PIPES 1
 
+/* Define name for the ssh-agent Windows named pipe */
+#define AGENT_PIPE_ID L"\\\\.\\pipe\\openssh-ssh-agent"
+
 /* define 1 if afunix.h is available */
 #define HAVE_AFUNIX_H 1
 
diff --git a/contrib/win32/win32compat/ssh-agent/agent.c b/contrib/win32/win32compat/ssh-agent/agent.c
index a6f2d64a5..f50bc58c1 100644
--- a/contrib/win32/win32compat/ssh-agent/agent.c
+++ b/contrib/win32/win32compat/ssh-agent/agent.c
@@ -43,8 +43,6 @@ HANDLE sshagent_client_primary_token;
 static HANDLE ioc_port = NULL;
 static BOOL debug_mode = FALSE;
 
-#define AGENT_PIPE_ID L"\\\\.\\pipe\\openssh-ssh-agent"
-
 static HANDLE event_stop_agent;
 static OVERLAPPED ol;
 static 	HANDLE pipe;
diff --git a/contrib/win32/win32compat/w32fd.c b/contrib/win32/win32compat/w32fd.c
index d3c6fbe26..732c1c4b5 100644
--- a/contrib/win32/win32compat/w32fd.c
+++ b/contrib/win32/win32compat/w32fd.c
@@ -300,12 +300,6 @@ w32_socket(int domain, int type, int protocol)
 	if (min_index == -1)
 		return -1;
 
-	#ifdef HAVE_AFUNIX_H
-	pio = socketio_socket(domain, type, protocol);
-	if (pio == NULL)
-		return -1;
-	pio->type = SOCK_FD;
-	#else
 	if (domain == AF_UNIX && type == SOCK_STREAM) {
 		pio = fileio_afunix_socket();
 		if (pio == NULL)
@@ -317,7 +311,65 @@ w32_socket(int domain, int type, int protocol)
 			return -1;
 		pio->type = SOCK_FD;
 	}
+
+	fd_table_set(pio, min_index);
+	debug4("socket:%d, socktype:%d, io:%p, fd:%d ", pio->sock, type, pio, min_index);
+	return min_index;
+}
+
+int
+w32_afunix_socket(struct sockaddr_un* addr)
+{
+	#ifdef HAVE_AFUNIX_H
+	/*
+		If HAVE_AFUNIX_H is defined, we can be dealing with the ssh-agent named pipe or
+		a AF_UNIX socket if ssh forwarding is enabled. If the addr->sun_path is the
+		the well known named pipe, we open the socket with w32_fileio.
+	*/
+	if(strcmp(addr->sun_path, "\\\\.\\pipe\\openssh-ssh-agent") == 0)
+		return w32_fileio_socket(SOCK_STREAM, 0);
+	else
+		return w32_unix_socket(SOCK_STREAM, 0);
+	#else
+		return w32_socket(AF_UNIX, SOCK_STREAM, 0);
 	#endif
+}
+
+int
+w32_unix_socket(int type, int protocol)
+{
+	int domain = AF_UNIX;
+	int min_index = fd_table_get_min_index();
+	struct w32_io* pio = NULL;
+
+	errno = 0;
+	if (min_index == -1)
+		return -1;
+
+	pio = socketio_socket(domain, type, protocol);
+	if (pio == NULL)
+		return -1;
+	pio->type = SOCK_FD;
+
+	fd_table_set(pio, min_index);
+	debug4("socket:%d, socktype:%d, io:%p, fd:%d ", pio->sock, type, pio, min_index);
+	return min_index;
+}
+
+int
+w32_fileio_socket(int type, int protocol)
+{
+	int min_index = fd_table_get_min_index();
+	struct w32_io* pio = NULL;
+
+	errno = 0;
+	if (min_index == -1)
+		return -1;
+
+	pio = fileio_afunix_socket();
+	if (pio == NULL)
+		return -1;
+	pio->type = NONSOCK_FD;
 
 	fd_table_set(pio, min_index);
 	debug4("socket:%d, socktype:%d, io:%p, fd:%d ", pio->sock, type, pio, min_index);
diff --git a/contrib/win32/win32compat/w32fd.h b/contrib/win32/win32compat/w32fd.h
index 0f1ee3a08..c6ced62cf 100644
--- a/contrib/win32/win32compat/w32fd.h
+++ b/contrib/win32/win32compat/w32fd.h
@@ -125,6 +125,7 @@ struct w32_io {
 #define FILETYPE(pio) (GetFileType(WINHANDLE(pio)))
 extern HANDLE main_thread;
 
+int w32_afunix_socket(struct sockaddr_un* addr);
 BOOL w32_io_is_blocking(struct w32_io*);
 BOOL w32_io_is_io_available(struct w32_io* pio, BOOL rd);
 int wait_for_any_event(HANDLE* events, int num_events, DWORD milli_seconds);
diff --git a/misc.c b/misc.c
index b187cc27d..244d37321 100644
--- a/misc.c
+++ b/misc.c
@@ -1928,7 +1928,11 @@ unix_listener(const char *path, int backlog, int unlink_first)
 		return -1;
 	}
 
+	#ifdef HAVE_AFUNIX_H
+	sock = w32_afunix_socket(&sunaddr);
+	#else
 	sock = socket(PF_UNIX, SOCK_STREAM, 0);
+	#endif
 	if (sock == -1) {
 		saved_errno = errno;
 		error_f("socket: %.100s", strerror(errno));
diff --git a/mux.c b/mux.c
index e7580ac74..c1ac0d2b5 100644
--- a/mux.c
+++ b/mux.c
@@ -2268,7 +2268,13 @@ muxclient(const char *path)
 		fatal("ControlPath too long ('%s' >= %u bytes)", path,
 		    (unsigned int)sizeof(addr.sun_path));
 
-	if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)
+	#ifdef HAVE_AFUNIX_H
+	sock = w32_afunix_socket(&addr);
+	#elif
+	sock = socket(PF_UNIX, SOCK_STREAM, 0);
+	#endif
+
+	if (sock == -1)
 		fatal_f("socket(): %s", strerror(errno));
 
 	if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
-- 
2.43.0

From 6cc801b79b60664651d4bc9923fa9ec346567238 Mon Sep 17 00:00:00 2001
From: Martin Fernandez <mfernandez@crunchloop.io>
Date: Sat, 15 Apr 2023 04:31:56 +0800
Subject: [PATCH 5/9] Comment regress/cfgmatch.sh temporary

---
 regress/cfgmatch.sh | 360 ++++++++++++++++++++++----------------------
 1 file changed, 180 insertions(+), 180 deletions(-)

diff --git a/regress/cfgmatch.sh b/regress/cfgmatch.sh
index d6931bb1b..b125bf553 100644
--- a/regress/cfgmatch.sh
+++ b/regress/cfgmatch.sh
@@ -1,183 +1,183 @@
 #	$OpenBSD: cfgmatch.sh,v 1.13 2021/06/08 06:52:43 djm Exp $
 #	Placed in the Public Domain.
 
-tid="sshd_config match"
-
-pidfile=$OBJ/remote_pid
-fwdport=3301
-fwd="-L $fwdport:127.0.0.1:$PORT"
-
-echo "ExitOnForwardFailure=yes" >> $OBJ/ssh_config
-echo "ExitOnForwardFailure=yes" >> $OBJ/ssh_proxy
-
-start_client()
-{
-	rm -f $pidfile
-	${SSH} -q $fwd "$@" somehost \
-	    exec sh -c \'"echo \$\$ > $pidfile; exec sleep 100"\' \
-	    >>$TEST_REGRESS_LOGFILE 2>&1 &
-	client_pid=$!
-	# Wait for remote end
-	n=0
-	while test ! -f $pidfile ; do
-		sleep 1
-		n=`expr $n + 1`
-		if test $n -gt 60; then
-			if [ "$os" == "windows" ]; then
-				# We can't kill windows process from cygwin / wsl so use "stop-process"
-				powershell.exe /c "stop-process -id $client_pid -Force" >/dev/null 2>&1
-			else
-				kill $client_pid
-			fi
-			fatal "timeout waiting for background ssh"
-		fi
-	done
-}
-
-stop_client()
-{
-	pid=`cat $pidfile`
-	if [ "$os" == "windows" ]; then
-		# We can't kill windows process from cygwin / wsl so use "stop-process"
-		powershell.exe /c "stop-process -id $pid -Force" >/dev/null 2>&1
-		powershell.exe /c "stop-process -name sleep -Force" >/dev/null 2>&1
-	else
-		if [ ! -z "$pid" ]; then
-			kill $pid
-		fi
-		wait
-	fi
-}
-
-cp $OBJ/sshd_proxy $OBJ/sshd_proxy_bak
-echo "PermitOpen 127.0.0.1:1 # comment" >>$OBJ/sshd_config
-echo "Match Address 127.0.0.1" >>$OBJ/sshd_config
-echo "PermitOpen 127.0.0.1:2 127.0.0.1:3 127.0.0.1:$PORT" >>$OBJ/sshd_config
-
-grep -v AuthorizedKeysFile $OBJ/sshd_proxy_bak > $OBJ/sshd_proxy
-echo "AuthorizedKeysFile /dev/null # comment" >>$OBJ/sshd_proxy
-echo "PermitOpen 127.0.0.1:1" >>$OBJ/sshd_proxy
-if [ "$os" == "windows" ]; then
-	# If User is domainuser then it will be in "domain/user" so convert it to "domain\user"
-	echo "Match user ${USER//\//\\}" >>$OBJ/sshd_proxy
-else
-	echo "Match user $USER" >>$OBJ/sshd_proxy
-fi
-
-echo "AuthorizedKeysFile /dev/null $OBJ/authorized_keys_%u" >>$OBJ/sshd_proxy
-echo "Match Address 127.0.0.1 # comment" >>$OBJ/sshd_proxy
-echo "PermitOpen 127.0.0.1:2 127.0.0.1:3 127.0.0.1:$PORT" >>$OBJ/sshd_proxy
-
-${SUDO} ${SSHD} -f $OBJ/sshd_config -T >/dev/null || \
-    fail "config w/match fails config test"
-
-start_sshd
-
-# Test Match + PermitOpen in sshd_config.  This should be permitted
-trace "match permitopen localhost"
-start_client -F $OBJ/ssh_config
-${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true || \
-    fail "match permitopen permit"
-stop_client
-
-# Same but from different source.  This should not be permitted
-trace "match permitopen proxy"
-start_client -F $OBJ/ssh_proxy
-${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true && \
-    fail "match permitopen deny"
-stop_client
-
-# Retry previous with key option, should also be denied.
-cp /dev/null $OBJ/authorized_keys_$USER
-for t in ${SSH_KEYTYPES}; do
-	printf 'permitopen="127.0.0.1:'$PORT'" ' >> $OBJ/authorized_keys_$USER
-	cat $OBJ/$t.pub >> $OBJ/authorized_keys_$USER
-done
-trace "match permitopen proxy w/key opts"
-start_client -F $OBJ/ssh_proxy
-${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true && \
-    fail "match permitopen deny w/key opt"
-stop_client
-
-# Test both sshd_config and key options permitting the same dst/port pair.
-# Should be permitted.
-trace "match permitopen localhost"
-start_client -F $OBJ/ssh_config
-${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true || \
-    fail "match permitopen permit"
-stop_client
-
-cp $OBJ/sshd_proxy_bak $OBJ/sshd_proxy
-echo "PermitOpen 127.0.0.1:1 127.0.0.1:$PORT 127.0.0.2:2" >>$OBJ/sshd_proxy
-if [ "$os" == "windows" ]; then
-	# If User is domainuser then it will be in "domain/user" so convert it to "domain\user"
-	echo "Match user ${USER//\//\\}" >>$OBJ/sshd_proxy
-else
-	echo "Match user $USER" >>$OBJ/sshd_proxy
-fi
-echo "PermitOpen 127.0.0.1:1 127.0.0.1:2" >>$OBJ/sshd_proxy
-
-# Test that a Match overrides a PermitOpen in the global section
-trace "match permitopen proxy w/key opts"
-start_client -F $OBJ/ssh_proxy
-${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true && \
-    fail "match override permitopen"
-stop_client
-
-cp $OBJ/sshd_proxy_bak $OBJ/sshd_proxy
-echo "PermitOpen 127.0.0.1:1 127.0.0.1:$PORT 127.0.0.2:2" >>$OBJ/sshd_proxy
-echo "Match User NoSuchUser" >>$OBJ/sshd_proxy
-echo "PermitOpen 127.0.0.1:1 127.0.0.1:2" >>$OBJ/sshd_proxy
-
-# Test that a rule that doesn't match doesn't override, plus test a
-# PermitOpen entry that's not at the start of the list
-trace "nomatch permitopen proxy w/key opts"
-start_client -F $OBJ/ssh_proxy
-${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true || \
-    fail "nomatch override permitopen"
-stop_client
-
-# Test parsing of available Match criteria (with the exception of Group which
-# requires knowledge of actual group memberships user running the test).
-params="user:user:u1 host:host:h1 address:addr:1.2.3.4 \
-    localaddress:laddr:5.6.7.8 rdomain:rdomain:rdom1"
-cp $OBJ/sshd_proxy_bak $OBJ/sshd_config
-echo 'Banner /nomatch' >>$OBJ/sshd_config
-for i in $params; do
-	config=`echo $i | cut -f1 -d:`
-	criteria=`echo $i | cut -f2 -d:`
-	value=`echo $i | cut -f3 -d:`
-	cat >>$OBJ/sshd_config <<EOD
-	    Match $config $value
-	      Banner /$value
-EOD
-done
-
-${SUDO} ${SSHD} -f $OBJ/sshd_config -T >/dev/null || \
-    fail "validate config for w/out spec"
-
-# Test matching each criteria.
-for i in $params; do
-	testcriteria=`echo $i | cut -f2 -d:`
-	expected=/`echo $i | cut -f3 -d:`
-	spec=""
-	for j in $params; do
-		config=`echo $j | cut -f1 -d:`
-		criteria=`echo $j | cut -f2 -d:`
-		value=`echo $j | cut -f3 -d:`
-		if [ "$criteria" = "$testcriteria" ]; then
-			spec="$criteria=$value,$spec"
-		else
-			spec="$criteria=1$value,$spec"
-		fi
-	done
-	trace "test spec $spec"
-	result=`${SUDO} ${SSHD} -f $OBJ/sshd_config -T -C "$spec" | \
-	    awk '$1=="banner"{print $2}'`
-	if [ "$os" == "windows" ]; then
-		result=${result/$'\r'/} # remove CR (carriage return)
-	fi
-	if [ "$result" != "$expected" ]; then
-		fail "match $config expected $expected got $result"
-	fi
-done
+# tid="sshd_config match"
+
+# pidfile=$OBJ/remote_pid
+# fwdport=3301
+# fwd="-L $fwdport:127.0.0.1:$PORT"
+
+# echo "ExitOnForwardFailure=yes" >> $OBJ/ssh_config
+# echo "ExitOnForwardFailure=yes" >> $OBJ/ssh_proxy
+
+# start_client()
+# {
+# 	rm -f $pidfile
+# 	${SSH} -q $fwd "$@" somehost \
+# 	    exec sh -c \'"echo \$\$ > $pidfile; exec sleep 100"\' \
+# 	    >>$TEST_REGRESS_LOGFILE 2>&1 &
+# 	client_pid=$!
+# 	# Wait for remote end
+# 	n=0
+# 	while test ! -f $pidfile ; do
+# 		sleep 1
+# 		n=`expr $n + 1`
+# 		if test $n -gt 60; then
+# 			if [ "$os" == "windows" ]; then
+# 				# We can't kill windows process from cygwin / wsl so use "stop-process"
+# 				powershell.exe /c "stop-process -id $client_pid -Force" >/dev/null 2>&1
+# 			else
+# 				kill $client_pid
+# 			fi
+# 			fatal "timeout waiting for background ssh"
+# 		fi
+# 	done
+# }
+
+# stop_client()
+# {
+# 	pid=`cat $pidfile`
+# 	if [ "$os" == "windows" ]; then
+# 		# We can't kill windows process from cygwin / wsl so use "stop-process"
+# 		powershell.exe /c "stop-process -id $pid -Force" >/dev/null 2>&1
+# 		powershell.exe /c "stop-process -name sleep -Force" >/dev/null 2>&1
+# 	else
+# 		if [ ! -z "$pid" ]; then
+# 			kill $pid
+# 		fi
+# 		wait
+# 	fi
+# }
+
+# cp $OBJ/sshd_proxy $OBJ/sshd_proxy_bak
+# echo "PermitOpen 127.0.0.1:1 # comment" >>$OBJ/sshd_config
+# echo "Match Address 127.0.0.1" >>$OBJ/sshd_config
+# echo "PermitOpen 127.0.0.1:2 127.0.0.1:3 127.0.0.1:$PORT" >>$OBJ/sshd_config
+
+# grep -v AuthorizedKeysFile $OBJ/sshd_proxy_bak > $OBJ/sshd_proxy
+# echo "AuthorizedKeysFile /dev/null # comment" >>$OBJ/sshd_proxy
+# echo "PermitOpen 127.0.0.1:1" >>$OBJ/sshd_proxy
+# if [ "$os" == "windows" ]; then
+# 	# If User is domainuser then it will be in "domain/user" so convert it to "domain\user"
+# 	echo "Match user ${USER//\//\\}" >>$OBJ/sshd_proxy
+# else
+# 	echo "Match user $USER" >>$OBJ/sshd_proxy
+# fi
+
+# echo "AuthorizedKeysFile /dev/null $OBJ/authorized_keys_%u" >>$OBJ/sshd_proxy
+# echo "Match Address 127.0.0.1 # comment" >>$OBJ/sshd_proxy
+# echo "PermitOpen 127.0.0.1:2 127.0.0.1:3 127.0.0.1:$PORT" >>$OBJ/sshd_proxy
+
+# ${SUDO} ${SSHD} -f $OBJ/sshd_config -T >/dev/null || \
+#     fail "config w/match fails config test"
+
+# start_sshd
+
+# # Test Match + PermitOpen in sshd_config.  This should be permitted
+# trace "match permitopen localhost"
+# start_client -F $OBJ/ssh_config
+# ${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true || \
+#     fail "match permitopen permit"
+# stop_client
+
+# # Same but from different source.  This should not be permitted
+# trace "match permitopen proxy"
+# start_client -F $OBJ/ssh_proxy
+# ${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true && \
+#     fail "match permitopen deny"
+# stop_client
+
+# # Retry previous with key option, should also be denied.
+# cp /dev/null $OBJ/authorized_keys_$USER
+# for t in ${SSH_KEYTYPES}; do
+# 	printf 'permitopen="127.0.0.1:'$PORT'" ' >> $OBJ/authorized_keys_$USER
+# 	cat $OBJ/$t.pub >> $OBJ/authorized_keys_$USER
+# done
+# trace "match permitopen proxy w/key opts"
+# start_client -F $OBJ/ssh_proxy
+# ${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true && \
+#     fail "match permitopen deny w/key opt"
+# stop_client
+
+# # Test both sshd_config and key options permitting the same dst/port pair.
+# # Should be permitted.
+# trace "match permitopen localhost"
+# start_client -F $OBJ/ssh_config
+# ${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true || \
+#     fail "match permitopen permit"
+# stop_client
+
+# cp $OBJ/sshd_proxy_bak $OBJ/sshd_proxy
+# echo "PermitOpen 127.0.0.1:1 127.0.0.1:$PORT 127.0.0.2:2" >>$OBJ/sshd_proxy
+# if [ "$os" == "windows" ]; then
+# 	# If User is domainuser then it will be in "domain/user" so convert it to "domain\user"
+# 	echo "Match user ${USER//\//\\}" >>$OBJ/sshd_proxy
+# else
+# 	echo "Match user $USER" >>$OBJ/sshd_proxy
+# fi
+# echo "PermitOpen 127.0.0.1:1 127.0.0.1:2" >>$OBJ/sshd_proxy
+
+# # Test that a Match overrides a PermitOpen in the global section
+# trace "match permitopen proxy w/key opts"
+# start_client -F $OBJ/ssh_proxy
+# ${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true && \
+#     fail "match override permitopen"
+# stop_client
+
+# cp $OBJ/sshd_proxy_bak $OBJ/sshd_proxy
+# echo "PermitOpen 127.0.0.1:1 127.0.0.1:$PORT 127.0.0.2:2" >>$OBJ/sshd_proxy
+# echo "Match User NoSuchUser" >>$OBJ/sshd_proxy
+# echo "PermitOpen 127.0.0.1:1 127.0.0.1:2" >>$OBJ/sshd_proxy
+
+# # Test that a rule that doesn't match doesn't override, plus test a
+# # PermitOpen entry that's not at the start of the list
+# trace "nomatch permitopen proxy w/key opts"
+# start_client -F $OBJ/ssh_proxy
+# ${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true || \
+#     fail "nomatch override permitopen"
+# stop_client
+
+# # Test parsing of available Match criteria (with the exception of Group which
+# # requires knowledge of actual group memberships user running the test).
+# params="user:user:u1 host:host:h1 address:addr:1.2.3.4 \
+#     localaddress:laddr:5.6.7.8 rdomain:rdomain:rdom1"
+# cp $OBJ/sshd_proxy_bak $OBJ/sshd_config
+# echo 'Banner /nomatch' >>$OBJ/sshd_config
+# for i in $params; do
+# 	config=`echo $i | cut -f1 -d:`
+# 	criteria=`echo $i | cut -f2 -d:`
+# 	value=`echo $i | cut -f3 -d:`
+# 	cat >>$OBJ/sshd_config <<EOD
+# 	    Match $config $value
+# 	      Banner /$value
+# EOD
+# done
+
+# ${SUDO} ${SSHD} -f $OBJ/sshd_config -T >/dev/null || \
+#     fail "validate config for w/out spec"
+
+# # Test matching each criteria.
+# for i in $params; do
+# 	testcriteria=`echo $i | cut -f2 -d:`
+# 	expected=/`echo $i | cut -f3 -d:`
+# 	spec=""
+# 	for j in $params; do
+# 		config=`echo $j | cut -f1 -d:`
+# 		criteria=`echo $j | cut -f2 -d:`
+# 		value=`echo $j | cut -f3 -d:`
+# 		if [ "$criteria" = "$testcriteria" ]; then
+# 			spec="$criteria=$value,$spec"
+# 		else
+# 			spec="$criteria=1$value,$spec"
+# 		fi
+# 	done
+# 	trace "test spec $spec"
+# 	result=`${SUDO} ${SSHD} -f $OBJ/sshd_config -T -C "$spec" | \
+# 	    awk '$1=="banner"{print $2}'`
+# 	if [ "$os" == "windows" ]; then
+# 		result=${result/$'\r'/} # remove CR (carriage return)
+# 	fi
+# 	if [ "$result" != "$expected" ]; then
+# 		fail "match $config expected $expected got $result"
+# 	fi
+# done
-- 
2.43.0

From 705ed7ed4f8063b7915f3b81db3eaa18b140a79a Mon Sep 17 00:00:00 2001
From: Martin Fernandez <mfernandez@crunchloop.io>
Date: Sat, 15 Apr 2023 04:34:48 +0800
Subject: [PATCH 6/9] Add back regress/cfgmatch.sh

---
 regress/cfgmatch.sh | 366 ++++++++++++++++++++++----------------------
 1 file changed, 183 insertions(+), 183 deletions(-)

diff --git a/regress/cfgmatch.sh b/regress/cfgmatch.sh
index b125bf553..a8e335654 100644
--- a/regress/cfgmatch.sh
+++ b/regress/cfgmatch.sh
@@ -1,183 +1,183 @@
-#	$OpenBSD: cfgmatch.sh,v 1.13 2021/06/08 06:52:43 djm Exp $
-#	Placed in the Public Domain.
-
-# tid="sshd_config match"
-
-# pidfile=$OBJ/remote_pid
-# fwdport=3301
-# fwd="-L $fwdport:127.0.0.1:$PORT"
-
-# echo "ExitOnForwardFailure=yes" >> $OBJ/ssh_config
-# echo "ExitOnForwardFailure=yes" >> $OBJ/ssh_proxy
-
-# start_client()
-# {
-# 	rm -f $pidfile
-# 	${SSH} -q $fwd "$@" somehost \
-# 	    exec sh -c \'"echo \$\$ > $pidfile; exec sleep 100"\' \
-# 	    >>$TEST_REGRESS_LOGFILE 2>&1 &
-# 	client_pid=$!
-# 	# Wait for remote end
-# 	n=0
-# 	while test ! -f $pidfile ; do
-# 		sleep 1
-# 		n=`expr $n + 1`
-# 		if test $n -gt 60; then
-# 			if [ "$os" == "windows" ]; then
-# 				# We can't kill windows process from cygwin / wsl so use "stop-process"
-# 				powershell.exe /c "stop-process -id $client_pid -Force" >/dev/null 2>&1
-# 			else
-# 				kill $client_pid
-# 			fi
-# 			fatal "timeout waiting for background ssh"
-# 		fi
-# 	done
-# }
-
-# stop_client()
-# {
-# 	pid=`cat $pidfile`
-# 	if [ "$os" == "windows" ]; then
-# 		# We can't kill windows process from cygwin / wsl so use "stop-process"
-# 		powershell.exe /c "stop-process -id $pid -Force" >/dev/null 2>&1
-# 		powershell.exe /c "stop-process -name sleep -Force" >/dev/null 2>&1
-# 	else
-# 		if [ ! -z "$pid" ]; then
-# 			kill $pid
-# 		fi
-# 		wait
-# 	fi
-# }
-
-# cp $OBJ/sshd_proxy $OBJ/sshd_proxy_bak
-# echo "PermitOpen 127.0.0.1:1 # comment" >>$OBJ/sshd_config
-# echo "Match Address 127.0.0.1" >>$OBJ/sshd_config
-# echo "PermitOpen 127.0.0.1:2 127.0.0.1:3 127.0.0.1:$PORT" >>$OBJ/sshd_config
-
-# grep -v AuthorizedKeysFile $OBJ/sshd_proxy_bak > $OBJ/sshd_proxy
-# echo "AuthorizedKeysFile /dev/null # comment" >>$OBJ/sshd_proxy
-# echo "PermitOpen 127.0.0.1:1" >>$OBJ/sshd_proxy
-# if [ "$os" == "windows" ]; then
-# 	# If User is domainuser then it will be in "domain/user" so convert it to "domain\user"
-# 	echo "Match user ${USER//\//\\}" >>$OBJ/sshd_proxy
-# else
-# 	echo "Match user $USER" >>$OBJ/sshd_proxy
-# fi
-
-# echo "AuthorizedKeysFile /dev/null $OBJ/authorized_keys_%u" >>$OBJ/sshd_proxy
-# echo "Match Address 127.0.0.1 # comment" >>$OBJ/sshd_proxy
-# echo "PermitOpen 127.0.0.1:2 127.0.0.1:3 127.0.0.1:$PORT" >>$OBJ/sshd_proxy
-
-# ${SUDO} ${SSHD} -f $OBJ/sshd_config -T >/dev/null || \
-#     fail "config w/match fails config test"
-
-# start_sshd
-
-# # Test Match + PermitOpen in sshd_config.  This should be permitted
-# trace "match permitopen localhost"
-# start_client -F $OBJ/ssh_config
-# ${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true || \
-#     fail "match permitopen permit"
-# stop_client
-
-# # Same but from different source.  This should not be permitted
-# trace "match permitopen proxy"
-# start_client -F $OBJ/ssh_proxy
-# ${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true && \
-#     fail "match permitopen deny"
-# stop_client
-
-# # Retry previous with key option, should also be denied.
-# cp /dev/null $OBJ/authorized_keys_$USER
-# for t in ${SSH_KEYTYPES}; do
-# 	printf 'permitopen="127.0.0.1:'$PORT'" ' >> $OBJ/authorized_keys_$USER
-# 	cat $OBJ/$t.pub >> $OBJ/authorized_keys_$USER
-# done
-# trace "match permitopen proxy w/key opts"
-# start_client -F $OBJ/ssh_proxy
-# ${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true && \
-#     fail "match permitopen deny w/key opt"
-# stop_client
-
-# # Test both sshd_config and key options permitting the same dst/port pair.
-# # Should be permitted.
-# trace "match permitopen localhost"
-# start_client -F $OBJ/ssh_config
-# ${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true || \
-#     fail "match permitopen permit"
-# stop_client
-
-# cp $OBJ/sshd_proxy_bak $OBJ/sshd_proxy
-# echo "PermitOpen 127.0.0.1:1 127.0.0.1:$PORT 127.0.0.2:2" >>$OBJ/sshd_proxy
-# if [ "$os" == "windows" ]; then
-# 	# If User is domainuser then it will be in "domain/user" so convert it to "domain\user"
-# 	echo "Match user ${USER//\//\\}" >>$OBJ/sshd_proxy
-# else
-# 	echo "Match user $USER" >>$OBJ/sshd_proxy
-# fi
-# echo "PermitOpen 127.0.0.1:1 127.0.0.1:2" >>$OBJ/sshd_proxy
-
-# # Test that a Match overrides a PermitOpen in the global section
-# trace "match permitopen proxy w/key opts"
-# start_client -F $OBJ/ssh_proxy
-# ${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true && \
-#     fail "match override permitopen"
-# stop_client
-
-# cp $OBJ/sshd_proxy_bak $OBJ/sshd_proxy
-# echo "PermitOpen 127.0.0.1:1 127.0.0.1:$PORT 127.0.0.2:2" >>$OBJ/sshd_proxy
-# echo "Match User NoSuchUser" >>$OBJ/sshd_proxy
-# echo "PermitOpen 127.0.0.1:1 127.0.0.1:2" >>$OBJ/sshd_proxy
-
-# # Test that a rule that doesn't match doesn't override, plus test a
-# # PermitOpen entry that's not at the start of the list
-# trace "nomatch permitopen proxy w/key opts"
-# start_client -F $OBJ/ssh_proxy
-# ${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true || \
-#     fail "nomatch override permitopen"
-# stop_client
-
-# # Test parsing of available Match criteria (with the exception of Group which
-# # requires knowledge of actual group memberships user running the test).
-# params="user:user:u1 host:host:h1 address:addr:1.2.3.4 \
-#     localaddress:laddr:5.6.7.8 rdomain:rdomain:rdom1"
-# cp $OBJ/sshd_proxy_bak $OBJ/sshd_config
-# echo 'Banner /nomatch' >>$OBJ/sshd_config
-# for i in $params; do
-# 	config=`echo $i | cut -f1 -d:`
-# 	criteria=`echo $i | cut -f2 -d:`
-# 	value=`echo $i | cut -f3 -d:`
-# 	cat >>$OBJ/sshd_config <<EOD
-# 	    Match $config $value
-# 	      Banner /$value
-# EOD
-# done
-
-# ${SUDO} ${SSHD} -f $OBJ/sshd_config -T >/dev/null || \
-#     fail "validate config for w/out spec"
-
-# # Test matching each criteria.
-# for i in $params; do
-# 	testcriteria=`echo $i | cut -f2 -d:`
-# 	expected=/`echo $i | cut -f3 -d:`
-# 	spec=""
-# 	for j in $params; do
-# 		config=`echo $j | cut -f1 -d:`
-# 		criteria=`echo $j | cut -f2 -d:`
-# 		value=`echo $j | cut -f3 -d:`
-# 		if [ "$criteria" = "$testcriteria" ]; then
-# 			spec="$criteria=$value,$spec"
-# 		else
-# 			spec="$criteria=1$value,$spec"
-# 		fi
-# 	done
-# 	trace "test spec $spec"
-# 	result=`${SUDO} ${SSHD} -f $OBJ/sshd_config -T -C "$spec" | \
-# 	    awk '$1=="banner"{print $2}'`
-# 	if [ "$os" == "windows" ]; then
-# 		result=${result/$'\r'/} # remove CR (carriage return)
-# 	fi
-# 	if [ "$result" != "$expected" ]; then
-# 		fail "match $config expected $expected got $result"
-# 	fi
-# done
+	$OpenBSD: cfgmatch.sh,v 1.13 2021/06/08 06:52:43 djm Exp $
+	Placed in the Public Domain.
+
+tid="sshd_config match"
+
+pidfile=$OBJ/remote_pid
+fwdport=3301
+fwd="-L $fwdport:127.0.0.1:$PORT"
+
+echo "ExitOnForwardFailure=yes" >> $OBJ/ssh_config
+echo "ExitOnForwardFailure=yes" >> $OBJ/ssh_proxy
+
+start_client()
+{
+	rm -f $pidfile
+	${SSH} -q $fwd "$@" somehost \
+	    exec sh -c \'"echo \$\$ > $pidfile; exec sleep 100"\' \
+	    >>$TEST_REGRESS_LOGFILE 2>&1 &
+	client_pid=$!
+	# Wait for remote end
+	n=0
+	while test ! -f $pidfile ; do
+		sleep 1
+		n=`expr $n + 1`
+		if test $n -gt 60; then
+			if [ "$os" == "windows" ]; then
+				# We can't kill windows process from cygwin / wsl so use "stop-process"
+				powershell.exe /c "stop-process -id $client_pid -Force" >/dev/null 2>&1
+			else
+				kill $client_pid
+			fi
+			fatal "timeout waiting for background ssh"
+		fi
+	done
+}
+
+stop_client()
+{
+	pid=`cat $pidfile`
+	if [ "$os" == "windows" ]; then
+		# We can't kill windows process from cygwin / wsl so use "stop-process"
+		powershell.exe /c "stop-process -id $pid -Force" >/dev/null 2>&1
+		powershell.exe /c "stop-process -name sleep -Force" >/dev/null 2>&1
+	else
+		if [ ! -z "$pid" ]; then
+			kill $pid
+		fi
+		wait
+	fi
+}
+
+cp $OBJ/sshd_proxy $OBJ/sshd_proxy_bak
+echo "PermitOpen 127.0.0.1:1 # comment" >>$OBJ/sshd_config
+echo "Match Address 127.0.0.1" >>$OBJ/sshd_config
+echo "PermitOpen 127.0.0.1:2 127.0.0.1:3 127.0.0.1:$PORT" >>$OBJ/sshd_config
+
+grep -v AuthorizedKeysFile $OBJ/sshd_proxy_bak > $OBJ/sshd_proxy
+echo "AuthorizedKeysFile /dev/null # comment" >>$OBJ/sshd_proxy
+echo "PermitOpen 127.0.0.1:1" >>$OBJ/sshd_proxy
+if [ "$os" == "windows" ]; then
+	# If User is domainuser then it will be in "domain/user" so convert it to "domain\user"
+	echo "Match user ${USER//\//\\}" >>$OBJ/sshd_proxy
+else
+	echo "Match user $USER" >>$OBJ/sshd_proxy
+fi
+
+echo "AuthorizedKeysFile /dev/null $OBJ/authorized_keys_%u" >>$OBJ/sshd_proxy
+echo "Match Address 127.0.0.1 # comment" >>$OBJ/sshd_proxy
+echo "PermitOpen 127.0.0.1:2 127.0.0.1:3 127.0.0.1:$PORT" >>$OBJ/sshd_proxy
+
+${SUDO} ${SSHD} -f $OBJ/sshd_config -T >/dev/null || \
+    fail "config w/match fails config test"
+
+start_sshd
+
+# Test Match + PermitOpen in sshd_config.  This should be permitted
+trace "match permitopen localhost"
+start_client -F $OBJ/ssh_config
+${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true || \
+    fail "match permitopen permit"
+stop_client
+
+# Same but from different source.  This should not be permitted
+trace "match permitopen proxy"
+start_client -F $OBJ/ssh_proxy
+${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true && \
+    fail "match permitopen deny"
+stop_client
+
+# Retry previous with key option, should also be denied.
+cp /dev/null $OBJ/authorized_keys_$USER
+for t in ${SSH_KEYTYPES}; do
+	printf 'permitopen="127.0.0.1:'$PORT'" ' >> $OBJ/authorized_keys_$USER
+	cat $OBJ/$t.pub >> $OBJ/authorized_keys_$USER
+done
+trace "match permitopen proxy w/key opts"
+start_client -F $OBJ/ssh_proxy
+${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true && \
+    fail "match permitopen deny w/key opt"
+stop_client
+
+# Test both sshd_config and key options permitting the same dst/port pair.
+# Should be permitted.
+trace "match permitopen localhost"
+start_client -F $OBJ/ssh_config
+${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true || \
+    fail "match permitopen permit"
+stop_client
+
+cp $OBJ/sshd_proxy_bak $OBJ/sshd_proxy
+echo "PermitOpen 127.0.0.1:1 127.0.0.1:$PORT 127.0.0.2:2" >>$OBJ/sshd_proxy
+if [ "$os" == "windows" ]; then
+	# If User is domainuser then it will be in "domain/user" so convert it to "domain\user"
+	echo "Match user ${USER//\//\\}" >>$OBJ/sshd_proxy
+else
+	echo "Match user $USER" >>$OBJ/sshd_proxy
+fi
+echo "PermitOpen 127.0.0.1:1 127.0.0.1:2" >>$OBJ/sshd_proxy
+
+# Test that a Match overrides a PermitOpen in the global section
+trace "match permitopen proxy w/key opts"
+start_client -F $OBJ/ssh_proxy
+${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true && \
+    fail "match override permitopen"
+stop_client
+
+cp $OBJ/sshd_proxy_bak $OBJ/sshd_proxy
+echo "PermitOpen 127.0.0.1:1 127.0.0.1:$PORT 127.0.0.2:2" >>$OBJ/sshd_proxy
+echo "Match User NoSuchUser" >>$OBJ/sshd_proxy
+echo "PermitOpen 127.0.0.1:1 127.0.0.1:2" >>$OBJ/sshd_proxy
+
+# Test that a rule that doesn't match doesn't override, plus test a
+# PermitOpen entry that's not at the start of the list
+trace "nomatch permitopen proxy w/key opts"
+start_client -F $OBJ/ssh_proxy
+${SSH} -q -p $fwdport -F $OBJ/ssh_config somehost true || \
+    fail "nomatch override permitopen"
+stop_client
+
+# Test parsing of available Match criteria (with the exception of Group which
+# requires knowledge of actual group memberships user running the test).
+params="user:user:u1 host:host:h1 address:addr:1.2.3.4 \
+    localaddress:laddr:5.6.7.8 rdomain:rdomain:rdom1"
+cp $OBJ/sshd_proxy_bak $OBJ/sshd_config
+echo 'Banner /nomatch' >>$OBJ/sshd_config
+for i in $params; do
+	config=`echo $i | cut -f1 -d:`
+	criteria=`echo $i | cut -f2 -d:`
+	value=`echo $i | cut -f3 -d:`
+	cat >>$OBJ/sshd_config <<EOD
+	    Match $config $value
+	      Banner /$value
+EOD
+done
+
+${SUDO} ${SSHD} -f $OBJ/sshd_config -T >/dev/null || \
+    fail "validate config for w/out spec"
+
+# Test matching each criteria.
+for i in $params; do
+	testcriteria=`echo $i | cut -f2 -d:`
+	expected=/`echo $i | cut -f3 -d:`
+	spec=""
+	for j in $params; do
+		config=`echo $j | cut -f1 -d:`
+		criteria=`echo $j | cut -f2 -d:`
+		value=`echo $j | cut -f3 -d:`
+		if [ "$criteria" = "$testcriteria" ]; then
+			spec="$criteria=$value,$spec"
+		else
+			spec="$criteria=1$value,$spec"
+		fi
+	done
+	trace "test spec $spec"
+	result=`${SUDO} ${SSHD} -f $OBJ/sshd_config -T -C "$spec" | \
+	    awk '$1=="banner"{print $2}'`
+	if [ "$os" == "windows" ]; then
+		result=${result/$'\r'/} # remove CR (carriage return)
+	fi
+	if [ "$result" != "$expected" ]; then
+		fail "match $config expected $expected got $result"
+	fi
+done
-- 
2.43.0

From 8ca026c1bb1963a6d66bc822930d68bdecd4a49a Mon Sep 17 00:00:00 2001
From: Martin Fernandez <mfernandez@crunchloop.io>
Date: Sat, 15 Apr 2023 06:57:17 +0800
Subject: [PATCH 7/9] Fix regress/cgmatch.sh comments

---
 regress/cfgmatch.sh | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/regress/cfgmatch.sh b/regress/cfgmatch.sh
index a8e335654..d6931bb1b 100644
--- a/regress/cfgmatch.sh
+++ b/regress/cfgmatch.sh
@@ -1,5 +1,5 @@
-	$OpenBSD: cfgmatch.sh,v 1.13 2021/06/08 06:52:43 djm Exp $
-	Placed in the Public Domain.
+#	$OpenBSD: cfgmatch.sh,v 1.13 2021/06/08 06:52:43 djm Exp $
+#	Placed in the Public Domain.
 
 tid="sshd_config match"
 
-- 
2.43.0

From fd096f59a64b2e66f6afa0fb9db491265e9df5d9 Mon Sep 17 00:00:00 2001
From: Martin Fernandez <mfernandez@crunchloop.io>
Date: Wed, 19 Apr 2023 12:44:51 +0800
Subject: [PATCH 9/9] Compare with AGENT_PIPE_ID

---
 contrib/win32/win32compat/w32fd.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/contrib/win32/win32compat/w32fd.c b/contrib/win32/win32compat/w32fd.c
index 732c1c4b5..534b256b5 100644
--- a/contrib/win32/win32compat/w32fd.c
+++ b/contrib/win32/win32compat/w32fd.c
@@ -326,7 +326,11 @@ w32_afunix_socket(struct sockaddr_un* addr)
 		a AF_UNIX socket if ssh forwarding is enabled. If the addr->sun_path is the
 		the well known named pipe, we open the socket with w32_fileio.
 	*/
-	if(strcmp(addr->sun_path, "\\\\.\\pipe\\openssh-ssh-agent") == 0)
+	int len = wcslen(AGENT_PIPE_ID);
+	char* pipeid = (char*)malloc(len + 1);
+	memset(pipeid, 0, len + 1);
+
+	if(wcstombs(pipeid, AGENT_PIPE_ID, len + 1) != (size_t) -1 && strcmp(addr->sun_path, pipeid) == 0)
 		return w32_fileio_socket(SOCK_STREAM, 0);
 	else
 		return w32_unix_socket(SOCK_STREAM, 0);
-- 
2.43.0

